--- a/usr/share/perl5/Lemonldap/NG/Portal/Lib/CrowdSecFilter.pm	1970-01-01 01:00:00.000000000 +0100
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Lib/CrowdSecFilter.pm	2025-12-26 11:03:15.513262743 +0100
@@ -0,0 +1,101 @@
+package Lemonldap::NG::Portal::Lib::CrowdSecFilter;
+
+use strict;
+use Mouse::Role;
+use Regexp::Assemble;
+
+use constant knownCat      => (qw(url));
+use constant knownSuffixes => (qw(re txt));
+
+# Initialization functions for CrowdsecFilter feature
+
+sub initializeFilters {
+    my ($self) = @_;
+    my $filters = $self->parseFilters( $self->conf->{crowdsecFilters} );
+    if ( $filters and %$filters ) {
+        foreach my $cat ( keys %$filters ) {
+            my $re = Regexp::Assemble->new;
+            eval {
+                $re->add( map { qr/(?i)$_/ } @{ $filters->{$cat}->{re} } )
+                  if $filters->{$cat}->{re};
+                $re->add( map { qr/(?i)\Q$_\E/ } @{ $filters->{$cat}->{txt} } )
+                  if @{ $filters->{$cat}->{txt} };
+            };
+            if ($@) {
+                $self->logger->error("Unable to parst category $cat: $@");
+            }
+            else {
+                $self->filters->{$cat} = $re->re;
+                $self->logger->debug("RE $cat: $re");
+            }
+        }
+    }
+}
+
+sub parseFilters {
+    my ( $self, $dirname, $res, $cat ) = @_;
+    $self->logger->debug("Crowdsec filters, parsing $dirname");
+    $res //= {};
+    my $fh;
+    unless ( opendir $fh, $dirname ) {
+        $self->logger->error("Unable to read directory $dirname: $!");
+        return $res;
+    }
+    my @files = grep /\w/, readdir $fh;
+    closedir $fh;
+  LOOP: foreach my $file (@files) {
+
+        # Sub-directories fixes the category
+        my $path = "$dirname/$file";
+        if ( -d $path ) {
+            if ($cat) {
+                $self->parseFilters( $path, $res, $cat );
+            }
+            elsif ( my ($t) = grep { $file =~ m/^${_}(?:[_\s-]|$)/ } knownCat ) {
+                $self->parseFilters( $path, $res, $t );
+            }
+            else {
+                $self->logger->error("Unknwon category for directory $path");
+            }
+            next LOOP;
+        }
+        $file =~ s/\.([^\.]+)$//;
+        my $type = $1;
+        unless ( $type and grep { $_ eq $type } knownSuffixes ) {
+            $self->logger->error("Bad suffix for $path, skipping");
+            next LOOP;
+        }
+        my $lcat = $cat;
+        unless ($lcat) {
+            $file =~ s/\.([^\.]+)$//;
+            $lcat = $1;
+            unless ($lcat) {
+                $self->logger->error("Malformed file $path (missing category)");
+                next LOOP;
+            }
+            unless ( grep { $_ eq $lcat } knownCat ) {
+                $self->logger->error("Unknown category $lcat for $path");
+                next LOOP;
+            }
+        }
+        unless ( open $fh, '<', $path ) {
+            $self->logger->error("Unable to read file $path: $!");
+            next LOOP;
+        }
+        $self->logger->debug(
+"Crowdsec filters, adding content of $path into category $lcat, type $type"
+        );
+        my $c = 0;
+        foreach (<$fh>) {
+            next if /^\s*#/;
+            next unless /\w/;
+            s/[\r\n]//g;
+            push @{ $res->{$lcat}->{$type} }, $_;
+            $c++;
+        }
+        $self->logger->debug("  -> $c lines added");
+    }
+    return $res;
+}
+
+1;
diff -aburN usr/share/perl5/Lemonldap/NG/Portal/Lib/CrowdSec.pm /home/yadd/dev/lemonldap/lemonldap-ng-portal/lib/Lemonldap/NG/Portal/Lib/CrowdSec.pm
--- a/usr/share/perl5/Lemonldap/NG/Portal/Lib/CrowdSec.pm	1970-01-01 01:00:00.000000000 +0100
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Lib/CrowdSec.pm	2025-12-26 11:04:24.106166932 +0100
@@ -0,0 +1,427 @@
+package Lemonldap::NG::Portal::Lib::CrowdSec;
+
+use strict;
+use Date::Parse;
+use Digest::SHA qw(sha256_hex);
+use JSON        qw(from_json to_json);
+use Mouse::Role;
+use POSIX qw(strftime);
+use Lemonldap::NG::Common::UserAgent;
+use Lemonldap::NG::Portal::Main::Constants qw(
+  PE_OK
+  PE_ERROR
+  PE_SESSIONNOTGRANTED
+);
+
+our $VERSION = '2.22.0';
+
+our $defaultBanValues = {
+    events_count     => 1,
+    scenario         => 'llng',
+    scenario_version => $VERSION,
+    leakspeed        => '1s',
+    remediation      => JSON::true,
+    simulated        => JSON::false,
+    capacity         => 1,
+};
+
+has ua => (
+    is      => 'rw',
+    lazy    => 1,
+    builder => sub {
+        my $ua = Lemonldap::NG::Common::UserAgent->new( $_[0]->{conf} );
+        $ua->agent( 'LLNG-CrowdsecAgent/' . $VERSION );
+        $ua->default_headers->header( 'Accept'       => 'application/json' );
+        $ua->default_headers->header( 'Content-Type' => 'application/json' );
+        return $ua;
+    }
+);
+
+has token    => ( is => 'rw' );
+has tokenExp => ( is => 'rw', default => 0 );
+
+has crowdsecUrl => ( is => 'rw' );
+
+sub _init {
+    my ($self) = @_;
+    if ( $self->conf->{crowdsecUrl} ) {
+        my $tmp = $self->conf->{crowdsecUrl};
+        $tmp =~ s#/+$##;
+        $self->crowdsecUrl($tmp);
+    }
+    else {
+        $self->logger->warn(
+            "crowdsecUrl isn't set, fallback to http://localhost:8080");
+        $self->crowdsecUrl('http://localhost:8080');
+    }
+    return 1;
+}
+
+sub bouncer {
+    my ( $self, $ip ) = @_;
+    my $resp = $self->ua->get(
+        $self->crowdsecUrl . "/v1/decisions?ip=$ip",
+        'Accept'    => 'application/json',
+        'X-Api-Key' => $self->conf->{crowdsecKey},
+    );
+    if ( $resp->is_error ) {
+        $self->logger->error( 'Bad CrowdSec response: ' . $resp->message );
+        $self->logger->debug( $resp->content );
+        return ( 1, PE_ERROR );
+    }
+    my $content = $resp->decoded_content;
+    if ( !$content or $content eq 'null' ) {
+        $self->userLogger->debug("$ip isn't known by CrowdSec");
+        return ( 1, PE_OK );
+    }
+    my $json_hash;
+    eval { $json_hash = from_json( $content, { allow_nonref => 1 } ); };
+    if ($@) {
+        $self->logger->error("Unable to decode CrowdSec response: $content");
+        $self->logger->debug($@);
+        return ( 1, PE_ERROR );
+    }
+    $self->logger->debug("CrowdSec response: $content");
+
+    # Response is "null" when IP is unknown
+    if ($json_hash) {
+
+        # CrowdSec may return more than one decision
+        foreach my $decision (@$json_hash) {
+            if ( $decision->{type} and $decision->{type} eq 'ban' ) {
+                return ( 0,
+                        "$ip banned by CrowdSec ('"
+                      . $decision->{scenario}
+                      . "' for $decision->{duration})" );
+            }
+        }
+        $self->userLogger->info("$ip not banned by CrowdSec");
+        return ( 1, PE_OK );
+    }
+}
+
+sub ban {
+    my $self = shift;
+    my ( $ip, $msg, $data ) = @_;
+    if ( my $token = $self->getToken ) {
+        my $request = HTTP::Request->new(
+            POST => $self->crowdsecUrl . '/v1/alerts',
+            [
+                'Content-Type'  => 'application/json',
+                'Authorization' => "Bearer " . $self->token,
+            ],
+            $self->_banPayload(@_)
+        );
+        my $resp = $self->ua->request($request);
+        unless ( $resp->is_success ) {
+            $self->logger->error(
+                join ' ',           'Unable to push alert',
+                $resp->status_line, $resp->decoded_content
+            );
+            return;
+        }
+        $self->logger->notice("Push new Crowdsec alert for $ip: $msg");
+        return 1;
+    }
+    else {
+        $self->logger->error('Unable to push Crowdsec decision');
+        return;
+    }
+}
+
+sub alert {
+    my $self = shift;
+    my ( $ip, $msg, $data ) = @_;
+
+    # No new ban decision for already banned IPs
+    my ($notBanned) = $self->bouncer($ip);
+
+    $data ||= {};
+    my $max = $self->conf->{crowdsecMaxFailures};
+
+    # Get both count and previous alerts for enrichment
+    my ( $count, $prevAlerts ) =
+      $self->getAlertsByIp( $ip, $data->{scenario} );
+    $count ||= 0;
+
+    $data->{remediation} =
+      ( $max and $count >= ( $max - 1 ) and $notBanned )
+      ? JSON::true
+      : JSON::false;
+    $self->logger->debug("Crowdsec alerts count is $count for $ip");
+    $data->{reason} ||= 'Reported by LLNG';
+    $msg ||= 'Reported by LLNG';
+
+    # Pass previous alerts for enrichment when ban decision is made
+    # Only include alerts that contributed to the decision (max - 1), capped at 30
+    if ( $data->{remediation} and $prevAlerts and @$prevAlerts ) {
+        my $limit = ( $max && $max > 1 ) ? $max - 1 : 30;
+        $limit = 30 if $limit > 30;
+        if ( @$prevAlerts > $limit ) {
+
+            # Take most recent alerts (sorted by start_at desc)
+            my @sorted =
+              sort { ( $b->{start_at} || '' ) cmp( $a->{start_at} || '' ) }
+              @$prevAlerts;
+            $data->{_prevAlerts} = [ @sorted[ 0 .. $limit - 1 ] ];
+        }
+        else {
+            $data->{_prevAlerts} = $prevAlerts;
+        }
+    }
+
+    return $self->ban( $ip, $msg, $data );
+}
+
+# Extract context from previous alerts for enrichment
+sub _extractAlertContext {
+    my ( $self, $prevAlerts ) = @_;
+    return unless $prevAlerts and @$prevAlerts;
+
+    my ( @logins, @uris, @timestamps );
+    my ( %seen_logins, %seen_uris );
+
+    foreach my $alert (@$prevAlerts) {
+
+        # Extract timestamp
+        push @timestamps, $alert->{start_at} if $alert->{start_at};
+
+        # Extract login and uri from events meta
+        if ( $alert->{events} and @{ $alert->{events} } ) {
+            foreach my $event ( @{ $alert->{events} } ) {
+                if ( $event->{meta} and @{ $event->{meta} } ) {
+                    foreach my $m ( @{ $event->{meta} } ) {
+                        if (    $m->{key} eq 'login'
+                            and $m->{value}
+                            and !$seen_logins{ $m->{value} }++ )
+                        {
+                            push @logins, $m->{value};
+                        }
+                        if (    $m->{key} eq 'uri'
+                            and $m->{value}
+                            and !$seen_uris{ $m->{value} }++ )
+                        {
+                            push @uris, $m->{value};
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    # Sort timestamps chronologically
+    @timestamps = sort @timestamps if @timestamps;
+
+    return {
+        logins      => \@logins,
+        uris        => \@uris,
+        first_alert => $timestamps[0],
+        last_alert  => $timestamps[-1],
+        count       => scalar @$prevAlerts,
+    };
+}
+
+sub getAlertsByIp {
+    my ( $self, $ip, $scenario ) = @_;
+    $scenario ||= $defaultBanValues->{scenario};
+    if ( my $token = $self->getToken ) {
+
+        # Use API filters to avoid default 50 alerts limit
+        my $url =
+            $self->crowdsecUrl
+          . '/v1/alerts?scope=ip&value='
+          . $ip
+          . '&scenario='
+          . $scenario;
+        my $request = HTTP::Request->new(
+            GET => $url,
+            [
+                'Authorization' => "Bearer " . $self->token,
+            ],
+        );
+        my $resp = $self->ua->request($request);
+        unless ( $resp->is_success ) {
+            $self->logger->error(
+                join ' ',           'Unable to get alerts',
+                $resp->status_line, $resp->decoded_content
+            );
+            return;
+        }
+        my $alerts = eval { from_json( $resp->decoded_content ) };
+        if ( $@ or !$alerts ) {
+            $self->logger->error( join ' ', 'Unable to read Crowdsec response:',
+                $@, $resp->decoded_content );
+            return;
+        }
+        my $timeLimit = time - ( $self->conf->{crowdsecBlockDelay} || 180 );
+
+        # API already filters by IP and scenario, just filter by time
+        my @ipAlerts =
+          grep { str2time( $_->{start_at} ) > $timeLimit } @$alerts;
+
+        # In list context, return both count and alerts for enrichment
+        return wantarray ? ( scalar @ipAlerts, \@ipAlerts ) : scalar @ipAlerts;
+    }
+    else {
+        $self->logger->error('Unable to push Crowdsec decision');
+        return;
+    }
+}
+
+sub _banPayload {
+    my ( $self, $ip, $msg, $data ) = @_;
+    $msg  ||= 'Banned by LLNG Crowdsec plugin';
+    $data ||= {};
+
+    # Extract and remove internal data
+    my $prevAlerts = delete $data->{_prevAlerts};
+
+    foreach my $k ( keys %$defaultBanValues ) {
+        $data->{$k} //= $defaultBanValues->{$k};
+    }
+    my $timestamp = strftime( "%Y-%m-%dT%H:%M:%SZ", gmtime );
+    $data->{start_at} ||= $timestamp;
+    $data->{stop_at}  ||= $timestamp;
+    $data->{source}   ||= { scope => 'ip', value => $ip };
+    my $reason = delete( $data->{reason} ) || 'Banned by LLNG';
+    my $login  = delete( $data->{login} );
+    my $uri    = delete( $data->{uri} );
+
+    # Include login in message for CAPI transmission
+    # (events[].meta is NOT forwarded by LAPI to CAPI)
+    $msg .= " (login: $login)" if $login;
+
+    $data->{scenario_hash} = sha256_hex( $data->{scenario} );
+    my @meta = (
+        { key => 'log_type', value => 'llng-auth' },
+        { key => 'reason',   value => $reason }
+    );
+    push @meta, { key => 'login', value => $login } if $login;
+    push @meta, { key => 'uri',   value => $uri }   if $uri;
+
+    # Enrich with historical context when ban decision is made
+    if ( $data->{remediation} and $prevAlerts ) {
+        my $context = $self->_extractAlertContext($prevAlerts);
+        if ($context) {
+            my @msg_parts;
+
+            # Add historical metadata
+            if ( @{ $context->{logins} } ) {
+                my $all_logins = join ', ', @{ $context->{logins} };
+                push @meta, { key => 'previous_logins', value => $all_logins };
+
+                # Truncate for message display
+                my $login_summary =
+                  @{ $context->{logins} } <= 3
+                  ? $all_logins
+                  : join( ', ', @{ $context->{logins} }[ 0 .. 2 ] ) . '...';
+                push @msg_parts, "attempted logins: $login_summary";
+            }
+
+            if ( @{ $context->{uris} } ) {
+                my $all_uris = join ', ', @{ $context->{uris} };
+                push @meta, { key => 'previous_uris', value => $all_uris };
+
+                # Truncate for message display
+                my $uri_summary =
+                  @{ $context->{uris} } <= 3
+                  ? $all_uris
+                  : join( ', ', @{ $context->{uris} }[ 0 .. 2 ] ) . '...';
+                push @msg_parts, "scanned URIs: $uri_summary";
+            }
+
+            if ( $context->{count} ) {
+                push @meta,
+                  { key => 'previous_alert_count', value => "" . $context->{count} };
+            }
+
+            if ( $context->{first_alert} ) {
+                push @meta,
+                  { key => 'first_alert', value => $context->{first_alert} };
+            }
+
+            if ( $context->{last_alert} ) {
+                push @meta,
+                  { key => 'last_alert', value => $context->{last_alert} };
+            }
+
+            # Enrich human-readable message
+            if ( $context->{count} ) {
+                $msg .= sprintf "; after %d previous alert(s)",
+                  $context->{count};
+            }
+            if (@msg_parts) {
+                $msg .= "; " . join( "; ", @msg_parts );
+            }
+        }
+    }
+
+    my $alert = {
+        %$data,
+        message => $msg,
+        events  => [ {
+                timestamp => $data->{start_at},
+                meta      => \@meta,
+                source    => $data->{source},
+            }
+        ],
+    };
+
+    # Add decisions array when remediation is requested
+    # This ensures the IP is immediately banned by CrowdSec
+    if ( $data->{remediation} ) {
+        my $duration = $self->conf->{crowdsecBanDuration} || '4h';
+        $alert->{decisions} = [ {
+                duration => $duration,
+                type     => 'ban',
+                scope    => 'ip',
+                value    => $ip,
+                origin   => 'llng',
+                scenario => $data->{scenario},
+            }
+        ];
+    }
+
+    return to_json( [$alert] );
+}
+
+sub getToken {
+    my ($self) = @_;
+
+    # Use token if available
+    return $self->token if $self->token and $self->tokenExp > time + 10;
+
+    # Get new token
+    my ( $user, $pwd ) =
+      map { $self->conf->{$_} } qw(crowdsecMachineId crowdsecPassword);
+    unless ( $user and $pwd ) {
+        $self->logger->error('Missing crowdsec credentials, aborting');
+        return;
+    }
+    my $request = HTTP::Request->new(
+        POST => $self->crowdsecUrl . '/v1/watchers/login',
+        [ 'Content-Type' => 'application/json' ],
+        to_json( {
+                machine_id => $user,
+                password   => $pwd,
+            }
+        )
+    );
+    my $resp = $self->ua->request($request);
+    unless ( $resp->is_success ) {
+        $self->logger->error( join ' ', 'Unable to connect to Crowdsec:',
+            $resp->status_line, $resp->decoded_content );
+        return;
+    }
+    my $json = eval { from_json( $resp->decoded_content ) };
+    if ( $@ or !$json ) {
+        $self->logger->error( join ' ', 'Unable to read Crowdsec response:',
+            $@, $resp->decoded_content );
+        return;
+    }
+    $self->tokenExp( str2time( $json->{expire} ) );
+    $self->logger->debug("Get Crowdsec token");
+    return $self->token( $json->{token} );
+}
+
+1;
--- a/usr/share/perl5/Lemonldap/NG/Portal/Main/Plugins.pm	2026-01-05 15:56:22.000000000 +0100
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Main/Plugins.pm	2025-12-26 11:03:15.517261686 +0100
@@ -47,6 +47,7 @@
       '::Plugins::AdaptativeAuthenticationLevel',
     refreshSessions         => '::Plugins::Refresh',
     crowdsec                => '::Plugins::CrowdSec',
+    crowdsecAgent           => '::Plugins::CrowdSecAgent',
     locationDetect          => '::Plugins::LocationDetect',
     globalLogoutRule        => '::Plugins::GlobalLogout',
     samlFederationFiles     => '::Plugins::SamlFederation',
--- a/usr/share/perl5/Lemonldap/NG/Portal/Plugins/CrowdSecAgent.pm	1970-01-01 01:00:00.000000000 +0100
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Plugins/CrowdSecAgent.pm	2025-12-26 11:04:24.106166932 +0100
@@ -0,0 +1,168 @@
+package Lemonldap::NG::Portal::Plugins::CrowdSecAgent;
+
+use strict;
+use Mouse;
+use Lemonldap::NG::Portal::Main::Constants qw(
+  PE_BADCERTIFICATE
+  PE_BADCREDENTIALS
+  PE_BADOTP
+  PE_CAPTCHAERROR
+  PE_MALFORMEDUSER
+  PE_OK
+  PE_OPENID_BADID
+  PE_SAML_SIGNATURE_ERROR
+  PE_SENDRESPONSE
+  PE_USERNOTFOUND
+);
+
+our $VERSION = '2.22.0';
+
+our @ALERTS = (
+    PE_USERNOTFOUND,         PE_BADCREDENTIALS,
+    PE_BADCERTIFICATE,       PE_MALFORMEDUSER,
+    PE_SAML_SIGNATURE_ERROR, PE_OPENID_BADID,
+    PE_CAPTCHAERROR,         PE_BADOTP,
+);
+
+extends 'Lemonldap::NG::Portal::Main::Plugin';
+with 'Lemonldap::NG::Portal::Lib::CrowdSec';
+
+has rule => ( is => 'rw', default => sub { 0 } );
+
+has filters => ( is => 'rw', default => sub { {} } );
+
+# Entrypoint
+use constant aroundSub => {
+
+    # Filter function (if crowdsecFilters is set)
+    controlUrl => 'controlUrl',
+
+    # Generate alerts for bad credentials
+    getUser      => 'sendIpAlerts',
+    authenticate => 'sendIpAlerts'
+};
+
+sub init {
+    my ($self) = @_;
+    $self->_init or return 0;
+    unless ($self->conf->{crowdsecMachineId}
+        and $self->conf->{crowdsecPassword} )
+    {
+        $self->logger->error(
+            'Crowdsec report enabled without machine_id and password');
+        return 0;
+    }
+    $self->rule(
+        $self->p->buildRule( $self->conf->{crowdsecAgent}, 'crowdsecAgent' ) );
+
+    if ( $self->conf->{crowdsecFilters} ) {
+        if ( -d $self->conf->{crowdsecFilters} ) {
+            with 'Lemonldap::NG::Portal::Lib::CrowdSecFilter';
+            $self->initializeFilters;
+        }
+        else {
+            $self->logger->error(
+                'Crowdsec filter directory not found, ignoring');
+        }
+    }
+    $self->conf->{crowdSecAgentResponseCode} ||= 404;
+
+    return 1;
+}
+
+sub sendIpAlerts {
+    my ( $self, $sub, $req ) = @_;
+    my $ret = $sub->($req);
+
+    if ( !$self->rule->( $req, $req->sessionInfo ) ) {
+        $self->logger->debug('Crowdsec-agent disabled for this env');
+        return $ret;
+    }
+
+    # Nothing to do if config doesn't allow alerts or if auth is OK
+    unless ( grep { $_ == $ret } @ALERTS ) {
+        $self->logger->debug(
+            "Crowdsec-Agent: not an authentication error: code $ret");
+        return $ret;
+    }
+    my $msg = 'Authentication failed: '
+      . &Lemonldap::NG::Portal::Main::Constants::portalConsts->{$ret};
+    $self->alert( $req->address, $msg,
+        { scenario => 'llng/badcredentials', reason => $msg, login => ( $req->user // '' ) } )
+      ? $self->auditLog(
+        $req,
+        code    => 200,
+        message => "Alert sent to Crowdsec: $msg",
+        ip      => $req->address
+      )
+      : $self->logger->error(
+        "Unable to send alert to Crowdsec (was '$msg' for " . $req->address );
+    return $ret;
+}
+
+sub controlUrl {
+    my ( $self, $sub, $req ) = @_;
+    my $ret = $sub->($req);
+    return $ret if $ret;
+
+    if ( !$self->rule->( $req, $req->sessionInfo ) ) {
+        $self->logger->debug('Crowdsec-agent disabled for this env');
+        return $ret;
+    }
+
+    return $ret unless $self->filters;
+    if (    $self->filters->{url}
+        and $req->env->{REQUEST_URI} =~ $self->filters->{url} )
+    {
+        my $msg = 'Bad URI detected: ' . $req->env->{REQUEST_URI};
+        $self->alert( $req->address, $msg,
+            { scenario => 'llng/urlscan', reason => $msg, uri => $req->env->{REQUEST_URI} } )
+          ? $self->auditLog(
+            $req,
+            code         => 200,
+            message      => "Alert sent to Crowdsec: $msg",
+            ip           => $req->address,
+            uri          => $req->env->{REQUEST_URI},
+            matchingPart => $&,
+          )
+          : $self->logger->error(
+            "Unable to send alert to Crowdsec (was '$msg' for "
+              . $req->address );
+
+        $req->response(
+
+        # Case "redirection", crowdSecAgentResponseValue is the "location" value
+            $self->conf->{crowdSecAgentResponseCode} =~ /^3/
+            ? $self->p->sendRawHtml(
+                $req,
+                $self->conf->{crowdSecAgentResponseValue},
+                {
+                    code    => $self->conf->{crowdSecAgentResponseCode},
+                    headers => [
+                        Location => (
+                            $self->conf->{crowdSecAgentResponseValue}
+                              || 'https://somewhere.else'
+                        )
+                    ],
+                }
+              )
+
+            # Case "custom response
+            : $self->conf->{crowdSecAgentResponseValue}
+            ? $self->p->sendRawHtml(
+                $req,
+                $self->conf->{crowdSecAgentResponseValue},
+                { code => $self->conf->{crowdSecAgentResponseCode} }
+              )
+
+            # Case "default Lemon response
+            : $self->sendError(
+                $req, '', $self->conf->{crowdSecAgentResponseCode}
+            )
+        );
+        return PE_SENDRESPONSE;
+    }
+    return $ret;
+}
+
+1;
diff -aburN usr/share/perl5/Lemonldap/NG/Portal/Plugins/CrowdSec.pm /home/yadd/dev/lemonldap/lemonldap-ng-portal/lib/Lemonldap/NG/Portal/Plugins/CrowdSec.pm
--- a/usr/share/perl5/Lemonldap/NG/Portal/Plugins/CrowdSec.pm	2025-05-21 10:24:46.000000000 +0200
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Plugins/CrowdSec.pm	2025-12-26 11:04:24.106166932 +0100
@@ -2,101 +2,71 @@
 
 use strict;
 use Mouse;
-use JSON qw(from_json);
-use Lemonldap::NG::Common::UserAgent;
 use Lemonldap::NG::Portal::Main::Constants qw(
   PE_OK
-  PE_ERROR
   PE_SESSIONNOTGRANTED
 );
 
-our $VERSION = '2.19.0';
+our $VERSION = '2.22.0';
 
 extends 'Lemonldap::NG::Portal::Main::Plugin';
+with 'Lemonldap::NG::Portal::Lib::CrowdSec';
 
 # Entrypoint
-use constant beforeAuth => 'check';
+use constant aroundSub => { controlUrl => 'checkCrowdsec' };
 
-has ua => (
-    is      => 'rw',
-    lazy    => 1,
-    builder => sub {
-
-        # TODO : LWP options to use a proxy for example
-        my $ua = Lemonldap::NG::Common::UserAgent->new( $_[0]->{conf} );
-        $ua->env_proxy();
-        return $ua;
-    }
-);
-has crowdsecUrl => ( is => 'rw' );
+has rule => ( is => 'rw', default => sub { 0 } );
 
 sub init {
     my ($self) = @_;
-    if ( $self->conf->{crowdsecUrl} ) {
-        my $tmp = $self->conf->{crowdsecUrl};
-        $tmp =~ s#/+$##;
-        $self->crowdsecUrl($tmp);
-    }
-    else {
-        $self->logger->warn(
-            "crowdsecUrl isn't set, fallback to http://localhost:8080");
-        $self->crowdsecUrl('http://localhost:8080');
-    }
-    $self->logger->info( 'CrowdSec policy is: '
-          . ( $self->conf->{crowdsecAction} ? 'reject' : 'warn' ) );
+    $self->_init or return 0;
+
+    # Parse activation rule
+    unless ( $self->conf->{crowdsecKey} ) {
+        $self->logger->error('Missing Crowdsec Bouncer key');
+        return 0;
+    }
+    $self->logger->info(
+        'CrowdSec policy is: ' . ( $self->conf->{crowdsecAction} || 'warn' ) );
+    $self->rule( $self->p->buildRule( $self->conf->{crowdsec}, 'crowdsec' ) );
     return 1;
 }
 
-sub check {
+sub checkCrowdsec {
-    my ( $self, $req ) = @_;
-    my $ip   = $req->address;
-    my $resp = $self->ua->get(
-        $self->crowdsecUrl . "/v1/decisions?ip=$ip",
-        'Accept'    => 'application/json',
-        'X-Api-Key' => $self->conf->{crowdsecKey},
-    );
-    if ( $resp->is_error and not !$self->conf->{crowdsecIgnoreFailures} ) {
-        $self->logger->error( 'Bad CrowdSec response: ' . $resp->message );
-        $self->logger->debug( $resp->content );
-        return PE_ERROR;
-    }
-    my $content = $resp->decoded_content;
-    if ( !$content or $content eq 'null' ) {
-        $self->userLogger->debug("$ip isn't known by CrowdSec");
+    my ( $self, $sub, $req ) = @_;
+    if ( !$self->rule->( $req, $req->sessionInfo ) ) {
+        $self->logger->debug('Crowdsec disabled for this env');
-        return PE_OK;
+        return $sub->($req);
     }
-    my $json_hash;
-    eval { $json_hash = from_json( $content, { allow_nonref => 1 } ); };
-    if ($@) {
-        $self->logger->error("Unable to decode CrowdSec response: $content");
-        $self->logger->debug($@);
-        return PE_ERROR;
-    }
-    $self->logger->debug("CrowdSec response: $content");
+    my $ip = $req->address;
+    my ( $ok, $err ) = $self->bouncer($ip);
 
-    # Response is "null" when IP is unknown
-    if ($json_hash) {
+    # bouncer() answer $ok=0 only when Crowdsec response rejects the given IP
+    return $sub->($req) if ( $ok and $err and $self->conf->{crowdsecIgnoreFailures} );
 
-        # CrowdSec may return more than one decision
-        foreach my $decision (@$json_hash) {
-            if ( $decision->{type} and $decision->{type} eq 'ban' ) {
-                $self->userLogger->warn( "$ip banned by CrowdSec ('"
-                      . $decision->{scenario}
-                      . "' for $decision->{duration})" );
+    # When $ok==0, $err contains the Crowdsec decision
+    unless ($ok) {
                 if ( $self->conf->{crowdsecAction} eq 'reject' ) {
-                    $self->userLogger->error("$ip rejected by CrowdSec");
+            $self->auditLog(
+                $req,
+                code    => 403,
+                message => $err,
+                ip      => $ip,
+            );
                     return PE_SESSIONNOTGRANTED;
                 }
                 else {
-                    $self->userLogger->error("$ip is banned by CrowdSec");
+            $self->auditLog(
+                $req,
+                code    => 200,
+                message => "$err (ignored)",
+                ip      => $ip,
+            );
                     $req->env->{CROWDSEC_REJECT} = 1;
-                    return PE_OK;
+                    return $sub->($req);
                 }
             }
-        }
-        $self->userLogger->info("$ip not banned by CrowdSec");
-        return PE_OK;
-    }
+    return $err ? $err : $sub->($req);
 }
 
 1;

new file mode 100644
--- /dev/null
+++ b/usr/share/perl5/Lemonldap/NG/Common/CrowdSec.pm
@@ -0,0 +1,260 @@
+package Lemonldap::NG::Common::CrowdSec;
+
+use strict;
+use Date::Parse;
+use JSON qw(from_json to_json);
+use Mouse::Role;
+use POSIX qw(strftime);
+use Lemonldap::NG::Common::UserAgent;
+use Lemonldap::NG::Portal::Main::Constants qw(
+  PE_OK
+  PE_ERROR
+  PE_SESSIONNOTGRANTED
+);
+
+our $VERSION = '2.22.0';
+
+our $defaultBanValues = {
+    events_count     => 1,
+    scenario         => 'llng',
+    scenario_hash    => 'llng',
+    scenario_version => $VERSION,
+    leakspeed        => '1s',
+    remediation      => JSON::true,
+    simulated        => JSON::false,
+    capacity         => 1,
+};
+
+has ua => (
+    is      => 'rw',
+    lazy    => 1,
+    builder => sub {
+        my $ua = Lemonldap::NG::Common::UserAgent->new( $_[0]->{conf} );
+        $ua->agent( 'LLNG-CrowdsecAgent/' . $VERSION );
+        $ua->default_headers->header( 'Accept'       => 'application/json' );
+        $ua->default_headers->header( 'Content-Type' => 'application/json' );
+        return $ua;
+    }
+);
+
+has token    => ( is => 'rw' );
+has tokenExp => ( is => 'rw', default => 0 );
+
+has crowdsecUrl => ( is => 'rw' );
+
+has scenario => ( is => 'rw', default => 'llng' );
+has scenarioHash => (
+    is      => 'rw',
+    lazy    => 1,
+    default => sub { $_[0]->scenario }
+);
+
+sub _init {
+    my ($self) = @_;
+    if ( $self->conf->{crowdsecUrl} ) {
+        my $tmp = $self->conf->{crowdsecUrl};
+        $tmp =~ s#/+$##;
+        $self->crowdsecUrl($tmp);
+    }
+    else {
+        $self->logger->warn(
+            "crowdsecUrl isn't set, fallback to http://localhost:8080");
+        $self->crowdsecUrl('http://localhost:8080');
+    }
+    return 1;
+}
+
+sub bouncer {
+    my ( $self, $ip ) = @_;
+    my $resp = $self->ua->get(
+        $self->crowdsecUrl . "/v1/decisions?ip=$ip",
+        'Accept'    => 'application/json',
+        'X-Api-Key' => $self->conf->{crowdsecKey},
+    );
+    if ( $resp->is_error ) {
+        $self->logger->error( 'Bad CrowdSec response: ' . $resp->message );
+        $self->logger->debug( $resp->content );
+        return ( 1, PE_ERROR );
+    }
+    my $content = $resp->decoded_content;
+    if ( !$content or $content eq 'null' ) {
+        $self->userLogger->debug("$ip isn't known by CrowdSec");
+        return ( 1, PE_OK );
+    }
+    my $json_hash;
+    eval { $json_hash = from_json( $content, { allow_nonref => 1 } ); };
+    if ($@) {
+        $self->logger->error("Unable to decode CrowdSec response: $content");
+        $self->logger->debug($@);
+        return ( 1, PE_ERROR );
+    }
+    $self->logger->debug("CrowdSec response: $content");
+
+    # Response is "null" when IP is unknown
+    if ($json_hash) {
+
+        # CrowdSec may return more than one decision
+        foreach my $decision (@$json_hash) {
+            if ( $decision->{type} and $decision->{type} eq 'ban' ) {
+                return ( 0,
+                        "$ip banned by CrowdSec ('"
+                      . $decision->{scenario}
+                      . "' for $decision->{duration})" );
+            }
+        }
+        $self->userLogger->info("$ip not banned by CrowdSec");
+        return ( 1, PE_OK );
+    }
+}
+
+sub ban {
+    my $self = shift;
+    my ( $ip, $msg, $data ) = @_;
+    if ( my $token = $self->getToken ) {
+        my $request = HTTP::Request->new(
+            POST => $self->crowdsecUrl . '/v1/alerts',
+            [
+                'Content-Type'  => 'application/json',
+                'Authorization' => "Bearer " . $self->token,
+            ],
+            $self->_banPayload(@_)
+        );
+        my $resp = $self->ua->request($request);
+        unless ( $resp->is_success ) {
+            $self->logger->error(
+                join ' ',           'Unable to push alert',
+                $resp->status_line, $resp->decoded_content
+            );
+            return;
+        }
+        $self->logger->notice("Push new Crowdsec alert for $ip: $msg");
+        return 1;
+    }
+    else {
+        $self->logger->error('Unable to push Crowdsec decision');
+        return;
+    }
+}
+
+sub alert {
+    my $self = shift;
+    my ( $ip, $msg, $data ) = @_;
+    $data ||= {};
+    my $max   = $self->conf->{crowdsecMaxFailures};
+    my $count = $self->getAlertsByIp($ip) || 0;
+    $data->{remediation} =
+      ( $max and $count >= ( $max - 1 ) ) ? JSON::true : JSON::false;
+    $self->logger->debug("Crowdsec alerts count is $count for $ip");
+    $data->{reason} ||= 'Reported by LLNG';
+    $msg ||= 'Reported by LLNG';
+    return $self->ban( $ip, $msg, $data );
+}
+
+sub getAlertsByIp {
+    my ( $self, $ip, $scenario ) = @_;
+    $scenario ||= $defaultBanValues->{scenario};
+    if ( my $token = $self->getToken ) {
+        my $url     = $self->crowdsecUrl . '/v1/alerts';
+        my $request = HTTP::Request->new(
+            GET => $url,
+            [
+                'Authorization' => "Bearer " . $self->token,
+            ],
+        );
+        my $resp = $self->ua->request($request);
+        unless ( $resp->is_success ) {
+            $self->logger->error(
+                join ' ',           'Unable to get alerts',
+                $resp->status_line, $resp->decoded_content
+            );
+            return;
+        }
+        my $alerts = eval { from_json( $resp->decoded_content ) };
+        if ( $@ or !$alerts ) {
+            $self->logger->error( join ' ', 'Unable to read Crowdsec response:',
+                $@, $resp->decoded_content );
+            return;
+        }
+        my $timeLimit = time - ( $self->conf->{crowdsecBlockDelay} || 180 );
+        my @ipAlerts =
+          grep {
+                  $_->{source}->{value} eq $ip
+              and $_->{scenario} eq $scenario
+              and str2time( $_->{start_at} ) > $timeLimit
+          } @$alerts;
+        return ( scalar @ipAlerts );
+    }
+    else {
+        $self->logger->error('Unable to push Crowdsec decision');
+        return;
+    }
+}
+
+sub _banPayload {
+    my ( $self, $ip, $msg, $data ) = @_;
+    $msg ||= 'Banned by LLNG Crowdsec plugin';
+    foreach my $k ( keys %$defaultBanValues ) {
+        $data->{$k} //= $defaultBanValues->{$k};
+    }
+    my $timestamp = strftime( "%Y-%m-%dT%H:%M:%SZ", gmtime );
+    $data->{start_at} ||= $timestamp;
+    $data->{stop_at}  ||= $timestamp;
+    $data->{source}   ||= { scope => 'ip', value => $ip };
+    my $reason = delete( $data->{reason} ) || 'Banned by LLNG';
+    return to_json( [ {
+                %$data,
+                message => $msg,
+                events  => [ {
+                        timestamp => $data->{start_at},
+                        meta      => [
+                            { key => 'log_type', value => 'llng-auth' },
+                            { key => 'reason',   value => $reason }
+                        ],
+                        source => $data->{source},
+                    }
+                ],
+            }
+        ]
+    );
+}
+
+sub getToken {
+    my ($self) = @_;
+
+    # Use token if available
+    return $self->token if $self->token and $self->tokenExp < time - 10;
+
+    # Get new token
+    my ( $user, $pwd ) =
+      map { $self->conf->{$_} } qw(crowdsecMachineId crowdsecPassword);
+    unless ( $user and $pwd ) {
+        $self->logger->error('Missing crowdsec credentials, aborting');
+        return;
+    }
+    my $request = HTTP::Request->new(
+        POST => $self->crowdsecUrl . '/v1/watchers/login',
+        [ 'Content-Type' => 'application/json' ],
+        to_json( {
+                machine_id => $user,
+                password   => $pwd,
+            }
+        )
+    );
+    my $resp = $self->ua->request($request);
+    unless ( $resp->is_success ) {
+        $self->logger->error( join ' ', 'Unable to connect to Crowdsec:',
+            $resp->status_line, $resp->decoded_content );
+        return;
+    }
+    my $json = eval { from_json( $resp->decoded_content ) };
+    if ( $@ or !$json ) {
+        $self->logger->error( join ' ', 'Unable to read Crowdsec response:',
+            $@, $resp->decoded_content );
+        return;
+    }
+    $self->tokenExp( str2time( $json->{expire} ) );
+    $self->logger->debug("Get Crowdsec token");
+    return $self->token( $json->{token} );
+}
+
+1;
--- a/usr/share/perl5/Lemonldap/NG/Portal/Main/Plugins.pm
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Main/Plugins.pm
@@ -45,6 +45,7 @@
       '::Plugins::AdaptativeAuthenticationLevel',
     refreshSessions         => '::Plugins::Refresh',
     crowdsec                => '::Plugins::CrowdSec',
+    crowdsecAgent           => '::Plugins::CrowdSecAgent',
     locationDetect          => '::Plugins::LocationDetect',
     globalLogoutRule        => '::Plugins::GlobalLogout',
     samlFederationFiles     => '::Plugins::SamlFederation',
--- a/usr/share/perl5/Lemonldap/NG/Portal/Plugins/CrowdSec.pm
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Plugins/CrowdSec.pm
@@ -2,101 +2,71 @@ package Lemonldap::NG::Portal::Plugins::CrowdSec;
 
 use strict;
 use Mouse;
-use JSON qw(from_json);
-use Lemonldap::NG::Common::UserAgent;
 use Lemonldap::NG::Portal::Main::Constants qw(
   PE_OK
-  PE_ERROR
   PE_SESSIONNOTGRANTED
 );
 
 our $VERSION = '2.19.0';
 
 extends 'Lemonldap::NG::Portal::Main::Plugin';
+with 'Lemonldap::NG::Common::CrowdSec';
 
 # Entrypoint
-use constant beforeAuth => 'check';
+use constant beforeAuth => 'checkIpStatus';
 
-has ua => (
-    is      => 'rw',
-    lazy    => 1,
-    builder => sub {
-
-        # TODO : LWP options to use a proxy for example
-        my $ua = Lemonldap::NG::Common::UserAgent->new( $_[0]->{conf} );
-        $ua->env_proxy();
-        return $ua;
-    }
-);
-has crowdsecUrl => ( is => 'rw' );
+has rule => ( is => 'rw', default => sub { 0 } );
 
 sub init {
     my ($self) = @_;
-    if ( $self->conf->{crowdsecUrl} ) {
-        my $tmp = $self->conf->{crowdsecUrl};
-        $tmp =~ s#/+$##;
-        $self->crowdsecUrl($tmp);
-    }
-    else {
-        $self->logger->warn(
-            "crowdsecUrl isn't set, fallback to http://localhost:8080");
-        $self->crowdsecUrl('http://localhost:8080');
+    $self->_init or return 0;
+
+    # Parse activation rule
+    unless ( $self->conf->{crowdsecKey} ) {
+        $self->logger->error('Missing Crowdsec Bouncer key');
+        return 0;
     }
-    $self->logger->info( 'CrowdSec policy is: '
-          . ( $self->conf->{crowdsecAction} ? 'reject' : 'warn' ) );
+    $self->logger->info(
+        'CrowdSec policy is: ' . ( $self->conf->{crowdsecAction} || 'warn' ) );
+    $self->rule( $self->p->buildRule( $self->conf->{crowdsec}, 'crowdsec' ) );
     return 1;
 }
 
-sub check {
+sub checkIpStatus {
     my ( $self, $req ) = @_;
-    my $ip   = $req->address;
-    my $resp = $self->ua->get(
-        $self->crowdsecUrl . "/v1/decisions?ip=$ip",
-        'Accept'    => 'application/json',
-        'X-Api-Key' => $self->conf->{crowdsecKey},
-    );
-    if ( $resp->is_error and not !$self->conf->{crowdsecIgnoreFailures} ) {
-        $self->logger->error( 'Bad CrowdSec response: ' . $resp->message );
-        $self->logger->debug( $resp->content );
-        return PE_ERROR;
-    }
-    my $content = $resp->decoded_content;
-    if ( !$content or $content eq 'null' ) {
-        $self->userLogger->debug("$ip isn't known by CrowdSec");
+    if ( !$self->rule->( $req, $req->sessionInfo ) ) {
+        $self->logger->debug('Crowdsec disabled for this env');
         return PE_OK;
     }
-    my $json_hash;
-    eval { $json_hash = from_json( $content, { allow_nonref => 1 } ); };
-    if ($@) {
-        $self->logger->error("Unable to decode CrowdSec response: $content");
-        $self->logger->debug($@);
-        return PE_ERROR;
-    }
-    $self->logger->debug("CrowdSec response: $content");
+    my $ip = $req->address;
+    my ( $ok, $err ) = $self->bouncer($ip);
 
-    # Response is "null" when IP is unknown
-    if ($json_hash) {
+    # bouncer() answer $ok=0 only when Crowdsec response rejects the given IP
+    return PE_OK if ( $ok and $err and $self->conf->{crowdsecIgnoreFailures} );
 
-        # CrowdSec may return more than one decision
-        foreach my $decision (@$json_hash) {
-            if ( $decision->{type} and $decision->{type} eq 'ban' ) {
-                $self->userLogger->warn( "$ip banned by CrowdSec ('"
-                      . $decision->{scenario}
-                      . "' for $decision->{duration})" );
-                if ( $self->conf->{crowdsecAction} eq 'reject' ) {
-                    $self->userLogger->error("$ip rejected by CrowdSec");
-                    return PE_SESSIONNOTGRANTED;
-                }
-                else {
-                    $self->userLogger->error("$ip is banned by CrowdSec");
-                    $req->env->{CROWDSEC_REJECT} = 1;
-                    return PE_OK;
-                }
-            }
+    # When $ok==0, $err contains the Crowdsec decision
+    unless ($ok) {
+        if ( $self->conf->{crowdsecAction} eq 'reject' ) {
+            $self->auditLog(
+                $req,
+                code    => 403,
+                message => $err,
+                ip      => $ip,
+            );
+            return PE_SESSIONNOTGRANTED;
+        }
+        else {
+            $self->auditLog(
+                $req,
+                code    => 200,
+                message => "$err (ignored)",
+                ip      => $ip,
+            );
+            $req->env->{CROWDSEC_REJECT} = 1;
+            return PE_OK;
         }
-        $self->userLogger->info("$ip not banned by CrowdSec");
-        return PE_OK;
     }
+    return $err ? $err : PE_OK;
 }
 
 1;
new file mode 100644
--- /dev/null
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Plugins/CrowdSecAgent.pm
@@ -0,0 +1,79 @@
+package Lemonldap::NG::Portal::Plugins::CrowdSecAgent;
+
+use strict;
+use Mouse;
+use Lemonldap::NG::Portal::Main::Constants qw(
+  PE_BADCERTIFICATE
+  PE_BADCREDENTIALS
+  PE_BADOTP
+  PE_CAPTCHAERROR
+  PE_MALFORMEDUSER
+  PE_OK
+  PE_OPENID_BADID
+  PE_SAML_SIGNATURE_ERROR
+  PE_USERNOTFOUND
+);
+
+our $VERSION = '2.19.0';
+
+our @ALERTS = (
+    PE_USERNOTFOUND,         PE_BADCREDENTIALS,
+    PE_BADCERTIFICATE,       PE_MALFORMEDUSER,
+    PE_SAML_SIGNATURE_ERROR, PE_OPENID_BADID,
+    PE_CAPTCHAERROR,         PE_BADOTP,
+);
+
+extends 'Lemonldap::NG::Portal::Main::Plugin';
+with 'Lemonldap::NG::Common::CrowdSec';
+
+has rule => ( is => 'rw', default => sub { 0 } );
+
+# Entrypoint
+use constant aroundSub =>
+  { getUser => 'sendIpAlerts', authenticate => 'sendIpAlerts' };
+
+sub init {
+    my ($self) = @_;
+    $self->_init or return 0;
+    unless ($self->conf->{crowdsecMachineId}
+        and $self->conf->{crowdsecPassword} )
+    {
+        $self->logger->error(
+            'Crowdsec report enabled without machine_id and password');
+        return 0;
+    }
+    $self->rule(
+        $self->p->buildRule( $self->conf->{crowdsecAgent}, 'crowdsecAgent' ) );
+    return 1;
+}
+
+sub sendIpAlerts {
+    my ( $self, $sub, $req ) = @_;
+    my $ret = $sub->($req);
+
+    if ( !$self->rule->( $req, $req->sessionInfo ) ) {
+        $self->logger->debug('Crowdsec-agent disabled for this env');
+        return $ret;
+    }
+
+    # Nothing to do if config doesn't allow alerts or if auth is OK
+    unless ( grep { $_ == $ret } @ALERTS ) {
+        $self->logger->debug(
+            "Crowdsec-Agent: not an authentication error: code $ret");
+        return $ret;
+    }
+    my $msg = 'Authentication failed: '
+      . &Lemonldap::NG::Portal::Main::Constants::portalConsts->{$ret};
+    $self->alert( $req->address, $msg )
+      ? $self->auditLog(
+        $req,
+        code    => 200,
+        message => "Alert sent to Crowdsec: $msg",
+        ip      => $req->address
+      )
+      : $self->logger->error(
+        "Unable to send alert to Crowdsec (was '$msg' for " . $req->address );
+    return $ret;
+}
+
+1;

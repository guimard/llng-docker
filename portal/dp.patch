--- a/usr/share/perl5/Lemonldap/NG/Portal/Issuer/OpenIDConnect.pm
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Issuer/OpenIDConnect.pm
@@ -1546,6 +1546,13 @@ sub token {
         return $self->_handleTokenExchange( $req, $rp );
     }
 
+    # Device Authorization Grant (RFC 8628)
+    elsif ( $grant_type eq 'urn:ietf:params:oauth:grant-type:device_code' ) {
+        my $h = $self->p->processHook( $req, 'oidcGotDeviceCodeGrant', $rp );
+        return $req->response if ( $h == PE_SENDRESPONSE );
+        return $self->sendOIDCError( $req, 'unsupported_grant_type', 400 );
+    }
+
     # Unknown or unspecified grant type
     else {
         $self->userLogger->error(
--- a/usr/share/perl5/Lemonldap/NG/Portal/Main/Plugins.pm
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Main/Plugins.pm
@@ -41,6 +41,8 @@ our @pList = (
     checkEntropy                        => '::Plugins::CheckEntropy',
     initializePasswordReset             => '::Plugins::InitializePasswordReset',
     ignorePollers                       => '::Plugins::IgnorePollers',
+    pamAccessActivation                 => '::Plugins::PamAccess',
+    sshCaActivation                     => '::Plugins::SSHCA',
     adaptativeAuthenticationLevelRules  =>
       '::Plugins::AdaptativeAuthenticationLevel',
     refreshSessions         => '::Plugins::Refresh',
@@ -56,6 +57,8 @@ our @pList = (
     'or::oidcRPMetaDataOptions/*/oidcRPMetaDataOptionsTokenXAuthorizedMatrix'
       => '::Plugins::MatrixTokenExchange',
     'twakeWellKnown' => 'Twake::Wellknown',
+    'or::oidcRPMetaDataOptions/*/oidcRPMetaDataOptionsAllowDeviceAuthorizationGrant' =>
+      '::Plugins::OIDCDeviceAuthorization',
 );
 
 ##@method list enabledPlugins
new file mode 100644
--- /dev/null
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Plugins/OIDCDeviceAuthorization.pm
@@ -0,0 +1,808 @@
+package Lemonldap::NG::Portal::Plugins::OIDCDeviceAuthorization;
+
+# OAuth 2.0 Device Authorization Grant - RFC 8628
+# https://datatracker.ietf.org/doc/html/rfc8628
+#
+# With PKCE extension (RFC 7636) for additional security
+
+use strict;
+use Mouse;
+use Lemonldap::NG::Portal::Main::Constants qw(
+  PE_ERROR
+  PE_SENDRESPONSE
+);
+use Crypt::URandom;
+use Digest::SHA qw(sha256_hex);
+
+our $VERSION = '2.23.0';
+
+extends qw(
+  Lemonldap::NG::Portal::Main::Plugin
+);
+
+# Hooks declaration - following OIDCNativeSso pattern
+use constant hook => {
+
+    # Hook called by OpenIDConnect.pm token method for device_code grant
+    oidcGotDeviceCodeGrant => 'deviceCodeGrantHook',
+};
+
+# Character set for user_code (RFC 8628 section 6.1)
+# Base-20 without vowels to avoid offensive words, easy to type on mobile
+use constant USER_CODE_CHARS => 'BCDFGHJKLMNPQRSTVWXZ';
+
+# Session kind for device authorization storage
+use constant sessionKind => 'DEVA';
+
+# Lazy access to OIDC issuer - following OIDCNativeSso pattern
+has oidc => (
+    is      => 'ro',
+    lazy    => 1,
+    default => sub {
+        $_[0]
+          ->p->loadedModules->{'Lemonldap::NG::Portal::Issuer::OpenIDConnect'};
+    }
+);
+
+has rule => (
+    is      => 'rw',
+    default => sub {
+        sub { 1 }
+    }
+);
+
+# Lazy access to CrowdSecAgent plugin (optional, for abuse reporting)
+has crowdsec => (
+    is      => 'ro',
+    lazy    => 1,
+    default => sub {
+        $_[0]
+          ->p->loadedModules->{'Lemonldap::NG::Portal::Plugins::CrowdSecAgent'};
+    }
+);
+
+# INITIALIZATION
+
+sub init {
+    my ($self) = @_;
+
+    # Check if OIDC issuer is enabled
+    unless ( $self->conf->{issuerDBOpenIDConnectActivation} ) {
+        $self->logger->error(
+            "OIDC issuer not enabled, Device Authorization plugin disabled");
+        return 0;
+    }
+
+    # Parse activation rule
+    if ( my $rule = $self->conf->{deviceAuthorizationRule} ) {
+        $self->rule( $self->p->buildRule( $rule, 'deviceAuthorizationRule' ) );
+        return 0 unless $self->rule;
+    }
+
+    # Device Authorization endpoint (RFC 8628 section 3.1)
+    # POST /oauth2/device - for devices to request authorization
+    my $oidc_path = $self->conf->{issuerDBOpenIDConnectPath} || '^/oauth2/';
+    $oidc_path =~ s/^.*?(\w+).*?$/$1/;    # Extract path name (e.g., "oauth2")
+    $self->addUnauthRoute(
+        $oidc_path => { 'device' => 'deviceAuthorizationEndpoint' },
+        ['POST']
+    );
+
+    # Device verification endpoint (for users) - /device
+    $self->addAuthRouteWithRedirect(
+        device => 'displayVerification',
+        ['GET']
+    );
+    $self->addAuthRoute(
+        device => 'submitVerification',
+        ['POST']
+    );
+
+    # Warn if CrowdSec is not configured (RFC 8628 recommends IP-based lockout)
+    # Check config rather than loadedModules since init order is not guaranteed
+    unless ($self->conf->{crowdsec}
+        and $self->conf->{crowdsecAgent} )
+    {
+        $self->logger->warn(
+"CrowdSecAgent plugin not configured. RFC 8628 recommends IP-based rate limiting for device authorization. Consider enabling CrowdSec for better security."
+        );
+    }
+
+    $self->logger->debug("Device Authorization Grant (RFC 8628) enabled");
+    return 1;
+}
+
+# Device Authorization endpoint (RFC 8628 section 3.1)
+# Called directly via route POST /oauth2/device
+sub deviceAuthorizationEndpoint {
+    my ( $self, $req ) = @_;
+
+    $self->logger->debug("Device Authorization endpoint called");
+
+    my $client_id = $req->param('client_id');
+
+    unless ($client_id) {
+        $self->logger->error(
+            "Missing client_id in device authorization request");
+        return $self->_sendDeviceError( $req, 'invalid_request',
+            'client_id is required' );
+    }
+
+    # Get RP from client_id
+    my $rp = $self->oidc->getRP($client_id);
+
+    unless ($rp) {
+        $self->logger->warn("Unknown client_id: $client_id");
+        return $self->_sendDeviceError( $req, 'invalid_client' );
+    }
+
+    # Check if this RP allows device authorization grant
+    unless ( $self->oidc->rpOptions->{$rp}
+        ->{oidcRPMetaDataOptionsAllowDeviceAuthorizationGrant} )
+    {
+        $self->logger->warn(
+            "Device authorization grant not allowed for RP $rp");
+        return $self->_sendDeviceError( $req, 'unauthorized_client' );
+    }
+
+    # Get requested scope
+    my $scope = $req->param('scope') || 'openid';
+
+    # PKCE support (RFC 7636)
+    my $code_challenge        = $req->param('code_challenge');
+    my $code_challenge_method = $req->param('code_challenge_method') || 'plain';
+
+    # Check if PKCE is required for this RP
+    if ( $self->oidc->rpOptions->{$rp}->{oidcRPMetaDataOptionsRequirePKCE}
+        and !$code_challenge )
+    {
+        $self->logger->warn(
+            "PKCE required but no code_challenge provided for RP $rp");
+        return $self->_sendDeviceError( $req, 'invalid_request',
+            'code_challenge is required' );
+    }
+
+    # Validate code_challenge_method if PKCE is used
+    if ($code_challenge) {
+        unless ( $code_challenge_method eq 'plain'
+            or $code_challenge_method eq 'S256' )
+        {
+            $self->logger->warn(
+                "Invalid code_challenge_method: $code_challenge_method");
+            return $self->_sendDeviceError( $req, 'invalid_request',
+                'code_challenge_method must be plain or S256' );
+        }
+        $self->logger->debug(
+"PKCE enabled for device authorization (method=$code_challenge_method)"
+        );
+    }
+
+    # Generate device_code (secret, used for polling)
+    my $device_code = $self->_generateDeviceCode();
+
+    # Generate user_code (shown to user)
+    my $user_code = $self->_generateUserCode();
+
+    # Store device authorization request
+    my $expiration =
+      $self->conf->{oidcServiceDeviceAuthorizationExpiration} || 600;
+    my $interval =
+      $self->conf->{oidcServiceDeviceAuthorizationPollingInterval} || 5;
+
+    # Create session with device_code hash as ID (for polling lookup)
+    my $device_code_hash = sha256_hex($device_code);
+
+    my $session_data = {
+        _type          => 'deviceauth',
+        _utime         => time() - $self->conf->{timeout} + $expiration,
+        device_code    => $device_code,
+        user_code      => $user_code,
+        client_id      => $client_id,
+        rp             => $rp,
+        scope          => $scope,
+        status         => 'pending',              # pending, approved, denied
+        created_at     => time(),
+        expires_at     => time() + $expiration,
+        code_challenge => $code_challenge,
+        code_challenge_method => $code_challenge_method,
+    };
+
+    # Store the device authorization using getApacheSession with fixed ID
+    my $session = $self->p->getApacheSession(
+        $device_code_hash,
+        kind      => sessionKind,
+        info      => $session_data,
+        force     => 1,
+        hashStore => 0,
+    );
+
+    unless ( $session && $session->id ) {
+        $self->logger->error("Failed to create device authorization session");
+        return $self->_sendDeviceError( $req, 'server_error' );
+    }
+
+    # Also create a session indexed by user_code for verification lookup
+    my $user_code_hash    = sha256_hex($user_code);
+    my $user_code_session = $self->p->getApacheSession(
+        $user_code_hash,
+        kind => sessionKind,
+        info => {
+            _type            => 'deviceauth_usercode',
+            _utime           => time() - $self->conf->{timeout} + $expiration,
+            device_code_hash => $device_code_hash,
+            user_code        => $user_code,
+            expires_at       => time() + $expiration,
+        },
+        force     => 1,
+        hashStore => 0,
+    );
+
+    unless ( $user_code_session && $user_code_session->id ) {
+        $self->logger->error("Failed to create user_code lookup session");
+
+        # Clean up the device_code session
+        $session->remove;
+        return $self->_sendDeviceError( $req, 'server_error' );
+    }
+
+    # Build verification URI
+    my $portal           = $self->p->HANDLER->tsv->{portal}->();
+    my $verification_uri = "$portal/device";
+    my $formatted_code   = $self->_formatUserCode($user_code);
+    my $verification_uri_complete =
+      "$portal/device?user_code=" . ( $user_code =~ s/-//gr );
+
+    # RFC 8628 section 3.2 - Device Authorization Response
+    my $response = {
+        device_code               => $device_code,
+        user_code                 => $formatted_code,
+        verification_uri          => $verification_uri,
+        verification_uri_complete => $verification_uri_complete,
+        expires_in                => $expiration + 0,
+        interval                  => $interval + 0,
+    };
+
+    $self->logger->debug(
+        "Device authorization created: user_code=$user_code, client=$client_id"
+    );
+    $self->userLogger->info(
+        "Device authorization initiated for client $client_id");
+
+    $self->auditLog(
+        $req,
+        code      => "ISSUER_OIDC_DEVICE_AUTH_INITIATED",
+        rp        => $rp,
+        user_code => $user_code,
+        message   => "Device authorization initiated for RP $rp",
+    );
+
+    return $self->p->sendJSONresponse( $req, $response );
+}
+
+# HOOK: Token endpoint handler for device_code grant
+# Called by OpenIDConnect.pm via processHook('oidcGotDeviceCodeGrant')
+sub deviceCodeGrantHook {
+    my ( $self, $req, $rp ) = @_;
+
+    $self->logger->debug("Device code grant hook called for RP $rp");
+
+    my $device_code = $req->param('device_code');
+    my $client_id   = $req->param('client_id')
+      || $self->oidc->rpOptions->{$rp}->{oidcRPMetaDataOptionsClientID};
+
+    unless ($device_code) {
+        return $self->_sendTokenError( $req, 'invalid_request',
+            'device_code is required' );
+    }
+
+    # Check if this RP allows device authorization grant
+    unless ( $self->oidc->rpOptions->{$rp}
+        ->{oidcRPMetaDataOptionsAllowDeviceAuthorizationGrant} )
+    {
+        $self->logger->warn(
+            "Device authorization grant not allowed for RP $rp");
+        return $self->_sendTokenError( $req, 'unauthorized_client' );
+    }
+
+    # Find the device authorization
+    my $device_auth = $self->_findByDeviceCode($device_code);
+
+    unless ($device_auth) {
+
+        # Token expired or invalid
+        return $self->_sendTokenError( $req, 'expired_token' );
+    }
+
+    # Verify RP matches
+    if ( $device_auth->{rp} ne $rp ) {
+        $self->logger->warn( "RP mismatch in device_code grant: expected "
+              . $device_auth->{rp}
+              . ", got $rp" );
+        return $self->_sendTokenError( $req, 'invalid_grant' );
+    }
+
+    # Check authorization status
+    my $status = $device_auth->{status} || 'pending';
+
+    if ( $status eq 'pending' ) {
+
+        # RFC 8628 section 3.5 - authorization_pending
+        return $self->_sendTokenError( $req, 'authorization_pending' );
+    }
+    elsif ( $status eq 'denied' ) {
+
+        # RFC 8628 section 3.5 - access_denied
+        $self->_deleteDeviceAuth($device_auth);
+        return $self->_sendTokenError( $req, 'access_denied' );
+    }
+    elsif ( $status eq 'approved' ) {
+
+        # Generate tokens!
+        return $self->_generateTokens( $req, $device_auth, $rp );
+    }
+    else {
+        $self->logger->error("Unknown device auth status: $status");
+        return $self->_sendTokenError( $req, 'server_error' );
+    }
+}
+
+# DEVICE VERIFICATION PAGE (for authenticated users)
+sub displayVerification {
+    my ( $self, $req ) = @_;
+
+    $self->logger->debug("Display device verification page");
+
+    # Check rule
+    unless ( $self->rule->( $req, $req->userData ) ) {
+        $self->userLogger->warn(
+            "User not allowed to verify device authorizations");
+        return $self->p->do( $req, [ sub { PE_ERROR } ] );
+    }
+
+    # Pre-fill user_code if provided in URL
+    my $user_code = $req->param('user_code') || '';
+    $user_code =~ s/[^A-Z0-9]//gi;    # Clean up
+
+    # Set template parameters
+    $req->data->{activeTimer} = 0;
+    $req->{user_code} = $user_code;
+
+    return $self->p->sendHtml(
+        $req, 'device',
+        params => {
+            USER_CODE => $user_code,
+            MSG       => '',
+        }
+    );
+}
+
+# DEVICE VERIFICATION SUBMIT
+sub submitVerification {
+    my ( $self, $req ) = @_;
+
+    $self->logger->debug("Device verification submitted");
+
+    # Check rule
+    unless ( $self->rule->( $req, $req->userData ) ) {
+        return $self->p->do( $req, [ sub { PE_ERROR } ] );
+    }
+
+    my $user_code = $req->param('user_code') || '';
+    $user_code =~ s/[^A-Z0-9]//gi;    # Remove formatting (dashes, spaces)
+    $user_code = uc($user_code);
+
+    unless ( $user_code && length($user_code) >= 6 ) {
+        return $self->_showVerificationError( $req, 'invalidUserCode' );
+    }
+
+    # Find the device authorization by user_code
+    my $device_auth = $self->_findByUserCode($user_code);
+    unless ($device_auth) {
+        $self->logger->info("Invalid or expired user_code: $user_code");
+
+        # Report to CrowdSec if available (potential bruteforce)
+        $self->_reportInvalidUserCode( $req, $user_code );
+
+        my $user = $req->userData->{ $self->conf->{whatToTrace} };
+        $self->auditLog(
+            $req,
+            code      => "ISSUER_OIDC_DEVICE_AUTH_INVALID_CODE",
+            user_code => $user_code,
+            user      => $user,
+            message   => "Invalid or expired user_code submitted by $user",
+        );
+
+        return $self->_showVerificationError( $req, 'invalidUserCode' );
+    }
+
+    # Check if already processed
+    if ( $device_auth->{status} ne 'pending' ) {
+        $self->logger->info("User code already processed: $user_code");
+        return $self->_showVerificationError( $req, 'codeAlreadyUsed' );
+    }
+
+    # Check action (approve or deny)
+    my $action = $req->param('action') || 'approve';
+
+    if ( $action eq 'deny' ) {
+
+        # User denied the authorization
+        $self->_updateDeviceAuthStatus( $device_auth, 'denied' );
+        my $user = $req->userData->{ $self->conf->{whatToTrace} };
+        $self->userLogger->notice(
+            "Device authorization denied by user $user for client "
+              . $device_auth->{client_id} );
+
+        $self->auditLog(
+            $req,
+            code      => "ISSUER_OIDC_DEVICE_AUTH_DENIED",
+            rp        => $device_auth->{rp},
+            user_code => $device_auth->{user_code},
+            user      => $user,
+            message   =>
+              "Device authorization denied by $user for RP $device_auth->{rp}",
+        );
+
+        return $self->p->sendHtml(
+            $req, 'device',
+            params => {
+                DEVICE_DENIED => 1,
+                MSG           => 'deviceDenied',
+            }
+        );
+    }
+
+    # Approve the authorization
+    # Store user info for token generation
+    my $user_session_id = $req->id || $req->userData->{_session_id};
+    my $user            = $req->userData->{ $self->conf->{whatToTrace} };
+    $self->_updateDeviceAuthStatus(
+        $device_auth,
+        'approved',
+        {
+            user_session_id => $user_session_id,
+            user            => $user,
+            approved_at     => time(),
+        }
+    );
+
+    $self->userLogger->notice(
+        "Device authorization approved by user $user for client "
+          . $device_auth->{client_id} );
+
+    $self->auditLog(
+        $req,
+        code      => "ISSUER_OIDC_DEVICE_AUTH_APPROVED",
+        rp        => $device_auth->{rp},
+        user_code => $device_auth->{user_code},
+        user      => $user,
+        message   =>
+          "Device authorization approved by $user for RP $device_auth->{rp}",
+    );
+
+    return $self->p->sendHtml(
+        $req, 'device',
+        params => {
+            DEVICE_APPROVED => 1,
+            CLIENT_ID       => $device_auth->{client_id},
+            SCOPE           => $device_auth->{scope},
+            MSG             => 'deviceApproved',
+        }
+    );
+}
+
+# PRIVATE METHODS
+
+sub _generateDeviceCode {
+    my ($self) = @_;
+
+    # 32 bytes of random data, hex encoded
+    return unpack( 'H*', Crypt::URandom::urandom(32) );
+}
+
+sub _generateUserCode {
+    my ($self) = @_;
+    my $length =
+      $self->conf->{oidcServiceDeviceAuthorizationUserCodeLength} || 8;
+    my $chars     = USER_CODE_CHARS;
+    my $chars_len = length($chars);
+    my $code      = '';
+
+    # Use cryptographically secure random bytes to generate the user code
+    my $bytes = Crypt::URandom::urandom($length);
+    foreach my $b ( split //, $bytes ) {
+        my $idx = ord($b) % $chars_len;
+        $code .= substr( $chars, $idx, 1 );
+    }
+    return $code;
+}
+
+sub _formatUserCode {
+    my ( $self, $code ) = @_;
+
+    # Format as XXXX-XXXX for readability
+    if ( length($code) == 8 ) {
+        return substr( $code, 0, 4 ) . '-' . substr( $code, 4, 4 );
+    }
+    return $code;
+}
+
+sub _findByUserCode {
+    my ( $self, $user_code ) = @_;
+
+    # Look up the user_code session to get the device_code_hash
+    my $user_code_hash = sha256_hex($user_code);
+
+    my $user_code_session =
+      $self->p->getApacheSession( $user_code_hash, kind => sessionKind, );
+
+    unless ( $user_code_session && $user_code_session->data ) {
+        $self->logger->debug("User code session not found: $user_code");
+        return undef;
+    }
+
+    # Check expiration
+    if ( time() > ( $user_code_session->data->{expires_at} || 0 ) ) {
+        $self->logger->debug("User code expired: $user_code");
+        $user_code_session->remove;
+        return undef;
+    }
+
+    my $device_code_hash = $user_code_session->data->{device_code_hash};
+    return $self->_getDeviceAuthByHash($device_code_hash);
+}
+
+sub _findByDeviceCode {
+    my ( $self, $device_code ) = @_;
+
+    my $device_code_hash = sha256_hex($device_code);
+    return $self->_getDeviceAuthByHash($device_code_hash);
+}
+
+sub _getDeviceAuthByHash {
+    my ( $self, $device_code_hash ) = @_;
+
+    my $session =
+      $self->p->getApacheSession( $device_code_hash, kind => sessionKind, );
+
+    unless ( $session && $session->data ) {
+        $self->logger->debug("Device auth session not found");
+        return undef;
+    }
+
+    # Check expiration
+    if ( time() > ( $session->data->{expires_at} || 0 ) ) {
+        $self->logger->debug("Device auth session expired");
+        $session->remove;
+        return undef;
+    }
+
+    # Return session data with session reference for updates
+    my $data = { %{ $session->data } };
+    $data->{_session}          = $session;
+    $data->{_device_code_hash} = $device_code_hash;
+
+    return $data;
+}
+
+sub _updateDeviceAuthStatus {
+    my ( $self, $device_auth, $status, $extra ) = @_;
+
+    my $session = $device_auth->{_session};
+    return unless $session;
+
+    # Update status
+    my $info = { status => $status };
+
+    # Add extra fields
+    if ($extra) {
+        for my $key ( keys %$extra ) {
+            $info->{$key} = $extra->{$key};
+        }
+    }
+
+    # Update session
+    $self->p->getApacheSession(
+        $session->id,
+        kind => sessionKind,
+        info => $info,
+    );
+}
+
+sub _deleteDeviceAuth {
+    my ( $self, $device_auth ) = @_;
+
+    # Delete the device_code session
+    if ( my $session = $device_auth->{_session} ) {
+        $session->remove;
+    }
+
+    # Also delete the user_code lookup session
+    if ( my $user_code = $device_auth->{user_code} ) {
+        my $user_code_hash = sha256_hex($user_code);
+        my $user_code_session =
+          $self->p->getApacheSession( $user_code_hash, kind => sessionKind, );
+        $user_code_session->remove if $user_code_session;
+    }
+}
+
+sub _generateTokens {
+    my ( $self, $req, $device_auth, $rp ) = @_;
+
+    # Validate PKCE if it was used
+    my $code_challenge        = $device_auth->{code_challenge};
+    my $code_challenge_method = $device_auth->{code_challenge_method};
+
+    if ($code_challenge) {
+        my $code_verifier = $req->param('code_verifier');
+
+        # Verify code_verifier is provided when code_challenge exists
+        unless ($code_verifier) {
+            $self->logger->error(
+                "code_verifier is required when code_challenge was provided");
+            return $self->_sendTokenError( $req, 'invalid_grant',
+                'code_verifier is required' );
+        }
+
+        # Use the OIDC issuer's validatePKCEChallenge method
+        unless (
+            $self->oidc->validatePKCEChallenge(
+                $code_verifier, $code_challenge, $code_challenge_method
+            )
+          )
+        {
+            $self->logger->error(
+                "PKCE validation failed for device code grant");
+            return $self->_sendTokenError( $req, 'invalid_grant',
+                'PKCE validation failed' );
+        }
+        $self->logger->debug("PKCE validation successful");
+    }
+
+    my $scope = $device_auth->{scope};
+
+    # Get the user's session
+    my $user_session_id = $device_auth->{user_session_id};
+    my $session         = $self->p->getApacheSession($user_session_id);
+
+    unless ($session) {
+        $self->logger->error("User session not found for device authorization");
+        return $self->_sendTokenError( $req, 'server_error' );
+    }
+
+    # Generate access token
+    my $access_token = $self->oidc->newAccessToken(
+        $req, $rp, $scope,
+        $session->data,
+        {
+            scope           => $scope,
+            rp              => $rp,
+            user_session_id => $user_session_id,
+            grant_type      => "device_code",
+        }
+    );
+
+    unless ($access_token) {
+        $self->logger->error("Failed to create access token");
+        return $self->_sendTokenError( $req, 'server_error' );
+    }
+
+    my $expires_in =
+      $self->oidc->rpOptions->{$rp}
+      ->{oidcRPMetaDataOptionsAccessTokenExpiration}
+      || $self->conf->{oidcServiceAccessTokenExpiration}
+      || 3600;
+
+    my $response = {
+        access_token => "$access_token",
+        token_type   => 'Bearer',
+        expires_in   => $expires_in + 0,
+        scope        => $scope,
+    };
+
+    # Generate ID token if openid scope is requested
+    if ( $scope =~ /\bopenid\b/ ) {
+        my $id_token =
+          $self->oidc->_generateIDToken( $req, $rp, $scope, $session->data, 0 );
+        if ($id_token) {
+            $response->{id_token} = $id_token;
+        }
+    }
+
+    # Generate refresh token if allowed
+    if ( $self->oidc->rpOptions->{$rp}->{oidcRPMetaDataOptionsRefreshToken} ) {
+        my $refresh_token = $self->oidc->newRefreshToken(
+            $rp,
+            {
+                scope           => $scope,
+                client_id       => $device_auth->{client_id},
+                _session_uid    => $session->data->{_user},
+                auth_time       => $session->data->{_lastAuthnUTime},
+                grant_type      => "device_code",
+                user_session_id => $user_session_id,
+                %{ $session->data },
+            }
+        );
+
+        if ($refresh_token) {
+            $response->{refresh_token} = $refresh_token->id;
+        }
+    }
+
+    # Clean up the device authorization
+    $self->_deleteDeviceAuth($device_auth);
+
+    $self->logger->debug("Device code grant completed for RP $rp");
+
+    my $user = $device_auth->{user};
+    $self->auditLog(
+        $req,
+        code      => "ISSUER_OIDC_DEVICE_AUTH_TOKEN_GRANTED",
+        rp        => $rp,
+        user_code => $device_auth->{user_code},
+        user      => $user,
+        message   => "Device code exchanged for tokens by $user for RP $rp",
+    );
+
+    $req->response( $self->p->sendJSONresponse( $req, $response ) );
+    return PE_SENDRESPONSE;
+}
+
+sub _sendDeviceError {
+    my ( $self, $req, $error, $description ) = @_;
+
+    my $response = { error => $error };
+    $response->{error_description} = $description if $description;
+
+    # Return PSGI response directly (used by deviceAuthorizationEndpoint route)
+    return $self->p->sendJSONresponse( $req, $response, code => 400 );
+}
+
+sub _sendTokenError {
+    my ( $self, $req, $error, $description ) = @_;
+
+    my $response = { error => $error };
+    $response->{error_description} = $description if $description;
+
+    # authorization_pending and slow_down should return 400
+    # expired_token and access_denied should return 400
+    $req->response(
+        $self->p->sendJSONresponse( $req, $response, code => 400 ) );
+    return PE_SENDRESPONSE;
+}
+
+sub _showVerificationError {
+    my ( $self, $req, $msg ) = @_;
+
+    return $self->p->sendHtml(
+        $req, 'device',
+        params => {
+            USER_CODE => $req->param('user_code') || '',
+            MSG       => $msg,
+            ERROR     => 1,
+        }
+    );
+}
+
+# CrowdSec integration methods
+
+sub _reportInvalidUserCode {
+    my ( $self, $req, $user_code ) = @_;
+
+    my $crowdsec = $self->crowdsec;
+    return unless $crowdsec && $crowdsec->can('alert');
+
+    my $ip  = $req->address;
+    my $msg = "RFC 8628: Invalid user_code attempt from $ip (code: $user_code)";
+
+    $crowdsec->alert(
+        $ip, $msg,
+        {
+            scenario => 'llng/device-auth-bruteforce',
+            reason   => $msg,
+        }
+    );
+    $self->logger->debug("Reported invalid user_code attempt to CrowdSec");
+}
+
+1;
new file mode 100644
--- /dev/null
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Plugins/PamAccess.pm
@@ -0,0 +1,1102 @@
+# PAM Access plugin for LemonLDAP::NG
+#
+# This plugin provides:
+# - /pam : Web interface for users to generate temporary PAM access tokens
+# - /pam/verify : Server-to-server endpoint to validate one-time user tokens
+# - /pam/authorize : Server-to-server endpoint for authorization checks
+#
+# User tokens are one-time use tokens stored as sessions (kind=PAMTOKEN).
+# They are destroyed after first use for security.
+# Server authentication uses Bearer tokens obtained via Device Authorization Grant.
+
+package Lemonldap::NG::Portal::Plugins::PamAccess;
+
+use strict;
+use Mouse;
+use JSON qw(from_json to_json);
+use Lemonldap::NG::Portal::Main::Constants qw(
+  PE_OK
+  PE_ERROR
+  PE_SENDRESPONSE
+);
+
+our $VERSION = '2.22.0';
+
+extends 'Lemonldap::NG::Portal::Main::Plugin';
+
+use constant name => 'PamAccess';
+
+# MenuTab configuration - rule for displaying the tab
+has rule => (
+    is      => 'ro',
+    lazy    => 1,
+    builder => sub { $_[0]->conf->{portalDisplayPamAccess} // 0 },
+);
+with 'Lemonldap::NG::Portal::MenuTab';
+
+# Access to OIDC module for token generation/validation
+has oidc => (
+    is      => 'ro',
+    lazy    => 1,
+    default => sub {
+        $_[0]
+          ->p->loadedModules->{'Lemonldap::NG::Portal::Issuer::OpenIDConnect'};
+    }
+);
+
+# RP name for PAM tokens
+has rpName => (
+    is      => 'ro',
+    lazy    => 1,
+    default => sub { $_[0]->conf->{pamAccessRp} || 'pam-access' },
+);
+
+# INITIALIZATION
+
+sub init {
+    my ($self) = @_;
+
+    # Check that OIDC issuer is enabled
+    unless ( $self->conf->{issuerDBOpenIDConnectActivation} ) {
+        $self->logger->error(
+            'PamAccess plugin requires OIDC issuer to be enabled');
+        return 0;
+    }
+
+    # Check that at least one RP has Device Authorization Grant enabled
+    my $deviceAuthEnabled = 0;
+    my $rpOptions         = $self->conf->{oidcRPMetaDataOptions} || {};
+    for my $rp ( keys %$rpOptions ) {
+        if ( $rpOptions->{$rp}
+            {oidcRPMetaDataOptionsAllowDeviceAuthorizationGrant} )
+        {
+            $deviceAuthEnabled = 1;
+            last;
+        }
+    }
+    unless ($deviceAuthEnabled) {
+        $self->logger->error(
+'PamAccess plugin requires at least one OIDC RP with Device Authorization Grant enabled'
+        );
+        return 0;
+    }
+
+    # Routes for authenticated users (token generation interface)
+    $self->addAuthRoute( pam => 'pamInterface', ['GET'] )
+      ->addAuthRoute( pam => 'generateToken', ['POST'] );
+
+    # Route for server-to-server authorization (Bearer token auth)
+    $self->addUnauthRoute(
+        pam => { authorize => 'authorize' },
+        ['POST']
+    );
+
+    # Route for server heartbeat (refresh token based)
+    $self->addUnauthRoute(
+        pam => { heartbeat => 'heartbeat' },
+        ['POST']
+    );
+
+    # Route for one-time token verification (server-to-server)
+    $self->addUnauthRoute(
+        pam => { verify => 'verifyToken' },
+        ['POST']
+    );
+
+    # Route for NSS user info lookup (server-to-server)
+    $self->addUnauthRoute(
+        pam => { userinfo => 'userinfo' },
+        ['POST']
+    );
+
+    return 1;
+}
+
+# MENUTAB - Display method for the portal menu tab
+
+sub display {
+    my ( $self, $req ) = @_;
+
+    return {
+        logo => 'key',
+        name => 'PamAccess',
+        id   => 'pamaccess',
+        html => $self->loadTemplate(
+            $req,
+            'pamaccess',
+            params => {
+                TOKEN => '',
+                LOGIN => $req->userData->{ $self->conf->{whatToTrace} } || '',
+                EXPIRES_IN       => '',
+                SHOW_TOKEN       => 0,
+                DEFAULT_DURATION => $self->conf->{pamAccessTokenDuration}
+                  || 600,
+                MAX_DURATION => $self->conf->{pamAccessMaxDuration} || 3600,
+                js => "$self->{p}->{staticPrefix}/common/js/pamaccess.js",
+            }
+        ),
+    };
+}
+
+# ROUTE HANDLERS
+
+# GET /pam - Display the token generation interface
+sub pamInterface {
+    my ( $self, $req ) = @_;
+
+    return $self->p->do( $req, [ sub { PE_OK } ] );
+}
+
+# POST /pam - Generate a new PAM access token (one-time use)
+sub generateToken {
+    my ( $self, $req ) = @_;
+
+    # Get requested duration
+    my $duration =
+      $req->param('duration') || $self->conf->{pamAccessTokenDuration} || 600;
+
+    # Enforce maximum duration
+    my $maxDuration = $self->conf->{pamAccessMaxDuration} || 3600;
+    $duration = $maxDuration if $duration > $maxDuration;
+
+    my $login  = $req->userData->{ $self->conf->{whatToTrace} };
+    my $groups = $req->userData->{groups} || '';
+
+    # Calculate _utime for automatic cleanup by purgeCentralCache
+    # _utime + timeout = expiration time
+    # So: _utime = now + duration - timeout
+    my $now     = time();
+    my $timeout = $self->conf->{timeout} || 7200;
+    my $utime   = $now + $duration - $timeout;
+
+    # Create one-time token as a session with kind=PAMTOKEN
+    my $tokenInfo = {
+        _type         => 'pamtoken',
+        _utime        => $utime,
+        _pamUser      => $login,
+        _pamGroups    => $groups,
+        _pamUid       => $req->userData->{uid} || $login,
+        _pamCreatedAt => $now,
+        _pamExpiresAt => $now + $duration,
+    };
+
+    # Add exported variables for user provisioning
+    my $exportedVars = $self->conf->{pamAccessExportedVars} || {};
+    for my $key ( keys %$exportedVars ) {
+        my $attr  = $exportedVars->{$key};
+        my $value = $req->userData->{$attr};
+        $tokenInfo->{"_pamAttr_$key"} = $value
+          if defined $value && $value ne '';
+    }
+
+    my $tokenSession = $self->p->getApacheSession(
+        undef,
+        info => $tokenInfo,
+        kind => 'PAMTOKEN'
+    );
+
+    unless ( $tokenSession && $tokenSession->id ) {
+        $self->logger->error('Failed to create PAM token session');
+        return $self->p->sendJSONresponse(
+            $req,
+            { error => 'Token generation failed' },
+            code => 500
+        );
+    }
+
+    my $token = $tokenSession->id;
+    $self->logger->info(
+        "PAM one-time token generated for user $login (TTL: ${duration}s)");
+
+    # Audit log for token generation
+    $self->p->auditLog(
+        $req,
+        code    => 'PAM_TOKEN_GENERATED',
+        user    => $login,
+        message =>
+          "PAM one-time token generated for user $login (TTL: ${duration}s)",
+        ttl => $duration,
+    );
+
+    return $self->p->sendJSONresponse(
+        $req,
+        {
+            token      => $token,
+            login      => $login,
+            expires_in => $duration,
+        }
+    );
+}
+
+# POST /pam/authorize - Server-to-server authorization check
+sub authorize {
+    my ( $self, $req ) = @_;
+
+    # 1. Validate Bearer token from Authorization header
+    my $access_token = $self->oidc->getEndPointAccessToken($req);
+    unless ($access_token) {
+        $self->logger->warn('PAM authorize: No Bearer token provided');
+        return $self->_unauthorizedResponse( $req, 'Bearer token required' );
+    }
+
+    my $tokenSession = $self->oidc->getAccessToken($access_token);
+    unless ($tokenSession) {
+        $self->logger->warn('PAM authorize: Invalid or expired Bearer token');
+        return $self->_unauthorizedResponse( $req, 'Invalid or expired token' );
+    }
+
+    # 2. Verify token was obtained via Device Authorization Grant
+    my $grant_type = $tokenSession->data->{grant_type} || '';
+    unless ( $grant_type eq 'device_code' ) {
+        $self->logger->warn(
+                "PAM authorize: Token not from Device Authorization Grant "
+              . "(grant_type: '$grant_type'). Server must enroll via /oauth2/device"
+        );
+        return $self->_forbiddenResponse( $req,
+'Server not enrolled. Use Device Authorization Grant to register this server.'
+        );
+    }
+
+    # 3. Verify token has correct scope (pam:server or pam)
+    my $scope = $tokenSession->data->{scope} || '';
+    unless ( $scope =~ /\bpam(?::server)?\b/ ) {
+        $self->logger->warn("PAM authorize: Invalid token scope '$scope'");
+        return $self->_forbiddenResponse( $req, 'Invalid token scope' );
+    }
+
+    # Log server identity from token
+    my $server_id = $tokenSession->data->{client_id} || 'unknown';
+    $self->logger->info(
+        "PAM authorize request from enrolled server: $server_id");
+
+    # 4. Parse JSON request body
+    my $body = eval { from_json( $req->content ) };
+    if ($@) {
+        $self->logger->error("PAM authorize: Invalid JSON body: $@");
+        return $self->_badRequest( $req, 'Invalid JSON' );
+    }
+
+    my $user         = $body->{user};
+    my $host         = $body->{host}         || '';
+    my $service      = $body->{service}      || 'ssh';
+    my $server_group = $body->{server_group} || 'default';
+
+    unless ($user) {
+        return $self->_badRequest( $req, 'Missing user parameter' );
+    }
+
+    $self->logger->debug(
+"PAM authorize: checking user '$user' for host '$host', service '$service', server_group '$server_group'"
+    );
+
+    # 4. Lookup user (without active session)
+    $req->user($user);
+    $req->data->{_pamAuthorize} = 1;
+    $req->steps( [
+            'getUser',                 'setSessionInfo',
+            $self->p->groupsAndMacros, 'setLocalGroups'
+        ]
+    );
+
+    my $error = $self->p->process($req);
+
+    if ( $error != PE_OK ) {
+        $self->logger->info(
+            "PAM authorize: User '$user' not found (error: $error)");
+
+        # Audit log for authorization failure (user not found)
+        $self->p->auditLog(
+            $req,
+            code         => 'PAM_AUTHZ_USER_NOT_FOUND',
+            user         => $user,
+            message      => "PAM authorization failed: user '$user' not found",
+            host         => $host,
+            service      => $service,
+            server_group => $server_group,
+            server_id    => $server_id,
+        );
+
+        return $self->p->sendJSONresponse(
+            $req,
+            {
+                authorized => JSON::false,
+                user       => $user,
+                reason     => 'User not found',
+            },
+            code => 200
+        );
+    }
+
+    # 5. Evaluate authorization rule based on server_group
+    my $result = $self->_checkPamRule( $req, $host, $service, $server_group );
+    my $authorized   = $result->{authorized};
+    my $sudo_allowed = $result->{sudo_allowed};
+
+    # Get groups for response
+    my $groups    = $req->sessionInfo->{groups} || '';
+    my @groupList = split /[,;\s]+/, $groups;
+
+    $self->logger->info( "PAM authorize: user '$user' "
+          . ( $authorized ? 'granted' : 'denied' )
+          . " access to host '$host'"
+          . ( $authorized && $sudo_allowed ? ' (sudo allowed)' : '' ) );
+
+    # Audit log for authorization result
+    if ($authorized) {
+        $self->p->auditLog(
+            $req,
+            code    => 'PAM_AUTHZ_SUCCESS',
+            user    => $user,
+            message =>
+              "PAM authorization granted for user '$user' on host '$host'",
+            host         => $host,
+            service      => $service,
+            server_group => $server_group,
+            server_id    => $server_id,
+            groups       => \@groupList,
+            sudo_allowed => $sudo_allowed,
+        );
+    }
+    else {
+        $self->p->auditLog(
+            $req,
+            code    => 'PAM_AUTHZ_DENIED',
+            user    => $user,
+            message =>
+              "PAM authorization denied for user '$user' on host '$host'",
+            host         => $host,
+            service      => $service,
+            server_group => $server_group,
+            server_id    => $server_id,
+            groups       => \@groupList,
+            reason       => 'Access denied by rule',
+        );
+    }
+
+    # Build response with permissions
+    my $response = {
+        authorized => $authorized ? JSON::true : JSON::false,
+        user       => $user,
+        groups     => \@groupList,
+    };
+
+    # Add permissions for authorized users
+    if ($authorized) {
+        $response->{permissions} =
+          { sudo_allowed => $sudo_allowed ? JSON::true : JSON::false, };
+
+        # Add user attributes for NSS/cache (from exported vars)
+        my $exportedVars = $self->conf->{pamAccessExportedVars} || {};
+        for my $key ( keys %$exportedVars ) {
+            my $attr  = $exportedVars->{$key};
+            my $value = $req->sessionInfo->{$attr};
+            if ( defined $value && $value ne '' ) {
+                $response->{$key} = $value;
+            }
+        }
+
+        # Check if offline mode is enabled for this user
+        my $offlineEnabled = $self->_evaluateOfflineMode($req);
+        if ($offlineEnabled) {
+            my $offlineTtl = $self->conf->{pamAccessOfflineTtl} || 86400;
+            $response->{offline} = {
+                enabled => JSON::true,
+                ttl     => $offlineTtl,
+            };
+            $self->logger->debug(
+"PAM authorize: offline mode enabled for user '$user' (TTL: ${offlineTtl}s)"
+            );
+        }
+    }
+    else {
+        $response->{reason} = 'Access denied by rule';
+    }
+
+    return $self->p->sendJSONresponse( $req, $response, code => 200 );
+}
+
+# HELPER METHODS
+
+# Check PAM authorization rule for a specific service type
+# Returns: { authorized => 0|1, sudo_allowed => 0|1 }
+sub _checkPamRule {
+    my ( $self, $req, $host, $service, $server_group ) = @_;
+
+    # Set variables available for rule evaluation
+    $req->sessionInfo->{_pamHost}        = $host;
+    $req->sessionInfo->{_pamService}     = $service;
+    $req->sessionInfo->{_pamServerGroup} = $server_group || 'default';
+
+    my $result = {
+        authorized   => 0,
+        sudo_allowed => 0,
+    };
+
+    # Determine which rule set to use based on service type
+    my $ssh_authorized = $self->_evaluateRule( $req, $server_group, 'ssh' );
+
+    # For SSH service, check SSH rules
+    if ( $service eq 'sshd' || $service eq 'ssh' ) {
+        $result->{authorized} = $ssh_authorized;
+    }
+
+    # For sudo service, check both SSH (must be connected) and sudo rules
+    elsif ( $service eq 'sudo' ) {
+
+        # User must first be authorized for SSH
+        if ($ssh_authorized) {
+            $result->{authorized} = 1;
+            $result->{sudo_allowed} =
+              $self->_evaluateRule( $req, $server_group, 'sudo' );
+        }
+    }
+
+    # For other services, fall back to legacy rules
+    else {
+        $result->{authorized} =
+          $self->_evaluateRule( $req, $server_group, 'legacy' );
+    }
+
+    # Also compute sudo_allowed for SSH requests (for response)
+    if ( $service eq 'sshd' || $service eq 'ssh' ) {
+        $result->{sudo_allowed} =
+          $self->_evaluateRule( $req, $server_group, 'sudo' );
+    }
+
+    return $result;
+}
+
+# Evaluate a specific rule type for a server group
+sub _evaluateRule {
+    my ( $self, $req, $server_group, $rule_type ) = @_;
+
+    $server_group ||= 'default';
+
+    # Select the appropriate rule set
+    my $rules;
+    if ( $rule_type eq 'ssh' ) {
+        $rules = $self->conf->{pamAccessSshRules} || {};
+
+        # Fallback to legacy rules if SSH rules not defined
+        if ( !%$rules ) {
+            $rules = $self->conf->{pamAccessServerGroups} || {};
+        }
+    }
+    elsif ( $rule_type eq 'sudo' ) {
+        $rules = $self->conf->{pamAccessSudoRules} || {};
+
+        # No fallback for sudo - if not defined, sudo is denied
+    }
+    else {
+        # Legacy mode
+        $rules = $self->conf->{pamAccessServerGroups} || {};
+    }
+
+    my $rule;
+
+    # 1. Look for rule matching the requested server_group
+    if ( exists $rules->{$server_group} ) {
+        $rule = $rules->{$server_group};
+        $self->logger->debug(
+            "PAM authorize: using $rule_type rule for group '$server_group'");
+    }
+
+    # 2. Fallback to 'default' group
+    elsif ( exists $rules->{default} ) {
+        $rule = $rules->{default};
+        $self->logger->debug(
+"PAM authorize: $rule_type rule for '$server_group' not found, using 'default'"
+        );
+    }
+
+    # 3. No rule found -> deny
+    else {
+        $self->logger->debug(
+            "PAM authorize: no $rule_type rule for '$server_group' or 'default'"
+        );
+        return 0;
+    }
+
+    # Simple boolean
+    return $rule if defined $rule && $rule =~ /^[01]$/;
+
+    # Empty or undefined rule -> deny
+    return 0 unless defined $rule && $rule ne '';
+
+    # Evaluate rule as expression
+    my $result =
+      $self->p->HANDLER->buildSub( $self->p->HANDLER->substitute($rule) )
+      ->( $req, $req->sessionInfo );
+
+    return $result ? 1 : 0;
+}
+
+# Evaluate if offline mode is enabled for this user
+sub _evaluateOfflineMode {
+    my ( $self, $req ) = @_;
+
+    my $rule = $self->conf->{pamAccessOfflineEnabled};
+
+    # Not configured or disabled
+    return 0 unless defined $rule && $rule ne '' && $rule ne '0';
+
+    # Simple boolean true
+    return 1 if $rule eq '1';
+
+    # Evaluate as expression
+    my $result =
+      $self->p->HANDLER->buildSub( $self->p->HANDLER->substitute($rule) )
+      ->( $req, $req->sessionInfo );
+
+    return $result ? 1 : 0;
+}
+
+sub _unauthorizedResponse {
+    my ( $self, $req, $message ) = @_;
+    $message ||= 'Unauthorized';
+
+    return $self->p->sendJSONresponse(
+        $req,
+        { error => $message },
+        code    => 401,
+        headers => [ 'WWW-Authenticate' => 'Bearer realm="pam"' ],
+    );
+}
+
+sub _forbiddenResponse {
+    my ( $self, $req, $message ) = @_;
+    $message ||= 'Forbidden';
+
+    return $self->p->sendJSONresponse( $req, { error => $message },
+        code => 403 );
+}
+
+sub _badRequest {
+    my ( $self, $req, $message ) = @_;
+    $message ||= 'Bad Request';
+
+    return $self->p->sendJSONresponse( $req, { error => $message },
+        code => 400 );
+}
+
+# POST /pam/verify - Verify and consume a one-time PAM token
+sub verifyToken {
+    my ( $self, $req ) = @_;
+
+    # 1. Validate server Bearer token from Authorization header
+    my $server_token = $self->oidc->getEndPointAccessToken($req);
+    unless ($server_token) {
+        $self->logger->warn('PAM verify: No server Bearer token provided');
+        return $self->_unauthorizedResponse( $req,
+            'Server Bearer token required' );
+    }
+
+    my $serverSession = $self->oidc->getAccessToken($server_token);
+    unless ($serverSession) {
+        $self->logger->warn('PAM verify: Invalid or expired server token');
+        return $self->_unauthorizedResponse( $req,
+            'Invalid or expired server token' );
+    }
+
+    # Verify server token was obtained via Device Authorization Grant
+    my $grant_type = $serverSession->data->{grant_type} || '';
+    unless ( $grant_type eq 'device_code' ) {
+        $self->logger->warn(
+                "PAM verify: Server token not from Device Authorization Grant "
+              . "(grant_type: '$grant_type')" );
+        return $self->_forbiddenResponse( $req,
+            'Server not enrolled. Use Device Authorization Grant.' );
+    }
+
+    # 2. Parse JSON request body
+    my $body = eval { from_json( $req->content ) };
+    if ($@) {
+        $self->logger->error("PAM verify: Invalid JSON body: $@");
+        return $self->_badRequest( $req, 'Invalid JSON' );
+    }
+
+    my $user_token = $body->{token};
+    unless ($user_token) {
+        return $self->_badRequest( $req, 'token parameter required' );
+    }
+
+    # Get server info for audit
+    my $server_id = $serverSession->data->{client_id} || 'unknown';
+
+    # 3. Retrieve the PAMTOKEN session
+    my $tokenSession =
+      $self->p->getApacheSession( $user_token, kind => 'PAMTOKEN' );
+    unless ($tokenSession) {
+        $self->logger->info("PAM verify: Invalid or expired token");
+
+        # Audit log for authentication failure
+        $self->p->auditLog(
+            $req,
+            code      => 'PAM_AUTH_INVALID_TOKEN',
+            message   => 'PAM authentication failed: invalid or expired token',
+            server_id => $server_id,
+            reason    => 'Invalid or expired token',
+        );
+
+        return $self->p->sendJSONresponse(
+            $req,
+            {
+                valid => JSON::false,
+                error => 'Invalid or expired token',
+            },
+            code => 200
+        );
+    }
+
+    # 4. Verify token type
+    my $type = $tokenSession->data->{_type} || '';
+    unless ( $type eq 'pamtoken' ) {
+        $self->logger->warn("PAM verify: Wrong token type '$type'");
+
+        # Audit log for security error
+        $self->p->auditLog(
+            $req,
+            code      => 'PAM_AUTH_WRONG_TOKEN_TYPE',
+            message   => "PAM authentication failed: wrong token type '$type'",
+            server_id => $server_id,
+            reason    => 'Invalid token type',
+        );
+
+        $tokenSession->remove;
+        return $self->p->sendJSONresponse(
+            $req,
+            {
+                valid => JSON::false,
+                error => 'Invalid token type',
+            },
+            code => 200
+        );
+    }
+
+    # 5. Check expiration
+    my $expiresAt = $tokenSession->data->{_pamExpiresAt} || 0;
+    if ( time() > $expiresAt ) {
+        my $user = $tokenSession->data->{_pamUser} || 'unknown';
+        $self->logger->info("PAM verify: Token expired");
+
+        # Audit log for expired token
+        $self->p->auditLog(
+            $req,
+            code    => 'PAM_AUTH_TOKEN_EXPIRED',
+            user    => $user,
+            message =>
+              "PAM authentication failed: token expired for user '$user'",
+            server_id => $server_id,
+            reason    => 'Token expired',
+        );
+
+        $tokenSession->remove;
+        return $self->p->sendJSONresponse(
+            $req,
+            {
+                valid => JSON::false,
+                error => 'Token expired',
+            },
+            code => 200
+        );
+    }
+
+    # 6. Extract user info
+    my $user      = $tokenSession->data->{_pamUser}   || '';
+    my $groups    = $tokenSession->data->{_pamGroups} || '';
+    my @groupList = $groups ? split( /[,;\s]+/, $groups ) : ();
+
+    # Extract exported attributes (prefixed with _pamAttr_)
+    my %attrs;
+    for my $key ( keys %{ $tokenSession->data } ) {
+        if ( $key =~ /^_pamAttr_(.+)$/ ) {
+            $attrs{$1} = $tokenSession->data->{$key};
+        }
+    }
+
+    # 7. CRITICAL: Remove the session (one-time use!)
+    $tokenSession->remove;
+
+    $self->logger->info("PAM verify: Token consumed for user '$user'");
+
+    # Audit log for successful authentication
+    $self->p->auditLog(
+        $req,
+        code      => 'PAM_AUTH_SUCCESS',
+        user      => $user,
+        message   => "PAM authentication successful for user '$user'",
+        server_id => $server_id,
+        groups    => \@groupList,
+    );
+
+    # 8. Return success with user info and exported attributes
+    return $self->p->sendJSONresponse(
+        $req,
+        {
+            valid  => JSON::true,
+            user   => $user,
+            groups => \@groupList,
+            ( %attrs ? ( attrs => \%attrs ) : () ),
+        },
+        code => 200
+    );
+}
+
+# POST /pam/heartbeat - Server heartbeat for monitoring
+sub heartbeat {
+    my ( $self, $req ) = @_;
+
+    # 1. Parse JSON request body
+    my $body = eval { from_json( $req->content ) };
+    if ($@) {
+        $self->logger->error("PAM heartbeat: Invalid JSON body: $@");
+        return $self->_badRequest( $req, 'Invalid JSON' );
+    }
+
+    # 2. Extract refresh_token from body
+    my $refresh_token_id = $body->{refresh_token};
+    unless ($refresh_token_id) {
+        return $self->_badRequest( $req, 'refresh_token required' );
+    }
+
+    # 3. Validate refresh token exists
+    my $rtSession = $self->oidc->getRefreshToken($refresh_token_id);
+    unless ($rtSession) {
+        $self->logger->warn('PAM heartbeat: invalid or expired refresh_token');
+        return $self->_unauthorizedResponse( $req, 'Invalid refresh_token' );
+    }
+
+    # 4. Verify token was obtained via Device Authorization Grant
+    my $grant_type = $rtSession->data->{grant_type} || '';
+    unless ( $grant_type eq 'device_code' ) {
+        $self->logger->warn(
+                "PAM heartbeat: Token not from Device Authorization Grant "
+              . "(grant_type: '$grant_type')" );
+        return $self->_forbiddenResponse( $req,
+            'Token not from Device Authorization Grant' );
+    }
+
+    # 5. Update metadata in refresh_token session
+    my $now      = time();
+    my $hostname = $body->{hostname} || 'unknown';
+    my $updates  = {
+        _pamServer      => 1,
+        _pamHostname    => $hostname,
+        _pamServerGroup => $body->{server_group} || 'default',
+        _pamVersion     => $body->{version}      || '',
+        _pamLastSeen    => $now,
+        _pamStatus      => 'active',
+    };
+
+    # Store stats as JSON string if provided
+    if ( $body->{stats} ) {
+        $updates->{_pamStats} = to_json( $body->{stats} );
+    }
+
+    # First heartbeat = enrollment timestamp
+    unless ( $rtSession->data->{_pamEnrolledAt} ) {
+        $updates->{_pamEnrolledAt} = $now;
+    }
+
+    # Update the refresh_token session
+    $self->oidc->updateRefreshToken( $rtSession->id, $updates );
+
+    $self->logger->debug("PAM heartbeat from $hostname");
+
+    # 6. Respond with next heartbeat interval
+    my $interval = $self->conf->{pamAccessHeartbeatInterval} || 300;
+    return $self->p->sendJSONresponse(
+        $req,
+        {
+            status         => 'ok',
+            next_heartbeat => $interval,
+            server_time    => $now,
+        }
+    );
+}
+
+# POST /pam/userinfo - Get user info for NSS module
+sub userinfo {
+    my ( $self, $req ) = @_;
+
+    # 1. Validate server Bearer token from Authorization header
+    my $server_token = $self->oidc->getEndPointAccessToken($req);
+    unless ($server_token) {
+        $self->logger->warn('PAM userinfo: No server Bearer token provided');
+        return $self->_unauthorizedResponse( $req,
+            'Server Bearer token required' );
+    }
+
+    my $serverSession = $self->oidc->getAccessToken($server_token);
+    unless ($serverSession) {
+        $self->logger->warn('PAM userinfo: Invalid or expired server token');
+        return $self->_unauthorizedResponse( $req,
+            'Invalid or expired server token' );
+    }
+
+    # Verify server token was obtained via Device Authorization Grant
+    my $grant_type = $serverSession->data->{grant_type} || '';
+    unless ( $grant_type eq 'device_code' ) {
+        $self->logger->warn(
+            "PAM userinfo: Server token not from Device Authorization Grant "
+              . "(grant_type: '$grant_type')" );
+        return $self->_forbiddenResponse( $req,
+            'Server not enrolled. Use Device Authorization Grant.' );
+    }
+
+    # 2. Parse JSON request body
+    my $body = eval { from_json( $req->content ) };
+    if ($@) {
+        $self->logger->error("PAM userinfo: Invalid JSON body: $@");
+        return $self->_badRequest( $req, 'Invalid JSON' );
+    }
+
+    my $user = $body->{user};
+    unless ($user) {
+        return $self->_badRequest( $req, 'user parameter required' );
+    }
+
+    # 3. Lookup user in backend
+    $req->user($user);
+    $req->data->{_pamUserinfo} = 1;
+    $req->steps( [
+            'getUser',                 'setSessionInfo',
+            $self->p->groupsAndMacros, 'setLocalGroups'
+        ]
+    );
+
+    my $error = $self->p->process($req);
+
+    if ( $error != PE_OK ) {
+        $self->logger->debug(
+            "PAM userinfo: User '$user' not found (error: $error)");
+        return $self->p->sendJSONresponse(
+            $req,
+            {
+                found => JSON::false,
+                user  => $user,
+            },
+            code => 200
+        );
+    }
+
+    # 4. Build response with user attributes
+    my $exportedVars = $self->conf->{pamAccessExportedVars} || {};
+    my %attrs;
+
+    for my $key ( keys %$exportedVars ) {
+        my $attr  = $exportedVars->{$key};
+        my $value = $req->sessionInfo->{$attr};
+        $attrs{$key} = $value if defined $value && $value ne '';
+    }
+
+    # Always include basic info
+    my $groups    = $req->sessionInfo->{groups} || '';
+    my @groupList = split /[,;\s]+/, $groups;
+
+    $self->logger->debug("PAM userinfo: Found user '$user'");
+
+    return $self->p->sendJSONresponse(
+        $req,
+        {
+            found  => JSON::true,
+            user   => $user,
+            groups => \@groupList,
+            %attrs,
+        },
+        code => 200
+    );
+}
+
+1;
+
+__END__
+
+=pod
+
+=encoding utf8
+
+=head1 NAME
+
+Lemonldap::NG::Portal::Plugins::PamAccess - PAM authentication/authorization plugin
+
+=head1 SYNOPSIS
+
+Enable this plugin in LemonLDAP::NG Manager:
+General Parameters > Plugins > PAM Access > Activation
+
+=head1 DESCRIPTION
+
+This plugin provides three main features:
+
+=head2 User Token Generation (/pam)
+
+Authenticated users can generate temporary ONE-TIME access tokens that can
+be used as passwords for PAM authentication (e.g., SSH login).
+
+Tokens are stored as sessions with kind='PAMTOKEN' and are automatically
+destroyed after first use, preventing replay attacks.
+
+=head2 Token Verification (/pam/verify)
+
+Servers validate and consume one-time user tokens. The token is destroyed
+immediately upon successful verification, ensuring single-use semantics.
+
+=head2 Server Authorization (/pam/authorize)
+
+Servers can check if a user is authorized to access a service, even when
+the user authenticates via SSH key (no token involved).
+
+=head1 ENDPOINTS
+
+=head2 GET /pam
+
+Display the token generation interface (requires authentication).
+
+=head2 POST /pam
+
+Generate a new one-time PAM access token.
+
+Parameters:
+- duration: Token validity in seconds (optional, default: 600)
+
+Response:
+{
+  "token": "session_id",
+  "login": "username",
+  "expires_in": 600
+}
+
+=head2 POST /pam/verify
+
+Verify and consume a one-time user token (server-to-server).
+
+Requires: Server Bearer token in Authorization header (from Device Auth Grant)
+
+Request body:
+{
+  "token": "user_token_to_verify"
+}
+
+Response:
+{
+  "valid": true/false,
+  "user": "username",
+  "groups": ["group1", "group2"],
+  "error": "..." (only if invalid)
+}
+
+IMPORTANT: The token is destroyed after successful verification (one-time use).
+
+=head2 POST /pam/authorize
+
+Check if a user is authorized (server-to-server).
+
+Requires: Bearer token in Authorization header
+
+Request body:
+{
+  "user": "username",
+  "host": "server.example.com",
+  "service": "ssh"
+}
+
+Response:
+{
+  "authorized": true/false,
+  "user": "username",
+  "groups": ["group1", "group2"],
+  "reason": "..." (only if denied)
+}
+
+=head2 POST /pam/heartbeat
+
+Server heartbeat for monitoring enrolled PAM servers.
+
+Request body:
+{
+  "refresh_token": "session_id_of_refresh_token",
+  "hostname": "server.example.com",
+  "server_group": "production",
+  "version": "1.0.0",
+  "stats": { "auth_success": 42, "auth_failure": 3 }
+}
+
+Response:
+{
+  "status": "ok",
+  "next_heartbeat": 300,
+  "server_time": 1702742400
+}
+
+=head1 CONFIGURATION
+
+=over
+
+=item pamAccessActivation
+
+Enable/disable the plugin (default: 0)
+
+=item portalDisplayPamAccess
+
+Rule for displaying the menu tab (default: 0)
+
+=item pamAccessTokenDuration
+
+Default token validity in seconds (default: 600)
+
+=item pamAccessMaxDuration
+
+Maximum token validity in seconds (default: 3600)
+
+=item pamAccessServerGroups
+
+Hash of server group names to authorization rules. Each PAM server can
+specify its group via the C<server_group> parameter in the authorize request.
+If a server's group is not found, the 'default' group rule is used.
+
+Example:
+  {
+    "production" => '$hGroup->{ops}',
+    "staging"    => '$hGroup->{ops} or $hGroup->{dev}',
+    "dev"        => '$hGroup->{dev} or $uid eq "admin"',
+    "default"    => '1'
+  }
+
+=item pamAccessRp
+
+OIDC Relying Party name for tokens (default: 'pam-access')
+
+=item pamAccessHeartbeatInterval
+
+Expected interval between server heartbeats in seconds (default: 300)
+
+=item pamAccessInactiveThreshold
+
+Time in seconds after which a server is considered inactive if no heartbeat
+received (default: 900)
+
+=item pamAccessHeartbeatRequired
+
+If enabled, servers must have a recent heartbeat to use /pam/authorize.
+This ensures that the PAM module is still active on the server. (default: 0)
+
+=back
+
+=head1 SEE ALSO
+
+L<Lemonldap::NG::Portal::Plugins::DeviceAuthorization> for server enrollment
+
+=head1 AUTHORS
+
+=over
+
+=item LemonLDAP::NG team L<https://lemonldap-ng.org/team>
+
+=back
+
+=head1 LICENSE AND COPYRIGHT
+
+See COPYING file for details.
+
+=cut
new file mode 100644
--- /dev/null
+++ b/usr/share/perl5/Lemonldap/NG/Portal/Plugins/SSHCA.pm
@@ -0,0 +1,1148 @@
+# SSH Certificate Authority plugin for LemonLDAP::NG
+#
+# This plugin provides SSH certificate signing functionality:
+# - /ssh/ca : Public CA key endpoint (no auth required)
+# - /ssh/revoked : Key Revocation List (KRL) endpoint (no auth required)
+# - /ssh/sign : Sign user's SSH public key (auth required)
+# - /ssh/certs : List/search issued certificates (auth required, admin only)
+# - /ssh/revoke : Revoke a certificate (auth required, admin only)
+#
+# Requires configuration of SSH CA key in LLNG keys store.
+
+package Lemonldap::NG::Portal::Plugins::SSHCA;
+
+use strict;
+use Mouse;
+use JSON qw(from_json to_json);
+use Lemonldap::NG::Common::Apache::Session;
+use Lemonldap::NG::Portal::Main::Constants qw(
+  PE_OK
+  PE_ERROR
+  PE_SENDRESPONSE
+);
+
+our $VERSION = '2.22.0';
+
+extends 'Lemonldap::NG::Portal::Main::Plugin';
+
+use constant name => 'SSHCA';
+
+# MenuTab configuration - rule for displaying the tab
+has rule => (
+    is      => 'ro',
+    lazy    => 1,
+    builder => sub { $_[0]->conf->{portalDisplaySshCa} // 0 },
+);
+with 'Lemonldap::NG::Portal::MenuTab';
+
+# INITIALIZATION
+
+sub init {
+    my ($self) = @_;
+
+    # Check that SSH CA is enabled
+    unless ( $self->conf->{sshCaActivation} ) {
+        $self->logger->debug('SSH CA plugin not enabled');
+        return 1;
+    }
+
+    $self->logger->debug('SSH CA plugin initialized');
+
+    # GET /ssh/ca - Public CA key (no auth required)
+    $self->addUnauthRoute(
+        ssh => { ca => 'sshCaPublicKey' },
+        ['GET']
+    );
+
+    # GET /ssh/revoked - Key Revocation List (no auth required)
+    $self->addUnauthRoute(
+        ssh => { revoked => 'sshCaKrl' },
+        ['GET']
+    );
+
+    # POST /ssh/sign - Sign user's SSH key (auth required)
+    $self->addAuthRoute(
+        ssh => { sign => 'sshCaSign' },
+        ['POST']
+    );
+
+    # GET /ssh/admin - Display the revocation interface (auth required, admin)
+    $self->addAuthRoute(
+        ssh => { admin => 'sshAdminInterface' },
+        ['GET']
+    );
+
+    # GET /ssh/certs - List/search certificates (auth required, admin)
+    $self->addAuthRoute(
+        ssh => { certs => 'sshCertsList' },
+        ['GET']
+    );
+
+    # POST /ssh/revoke - Revoke a certificate (auth required, admin)
+    $self->addAuthRoute(
+        ssh => { revoke => 'sshCertRevoke' },
+        ['POST']
+    );
+
+    # GET /ssh/* - Display the signing interface (auth required, wildcard route)
+    $self->addAuthRoute( ssh => { '*' => 'sshInterface' }, ['GET'] );
+
+    return 1;
+}
+
+# MENUTAB - Display method for the portal menu tab
+
+sub display {
+    my ( $self, $req ) = @_;
+
+    # Max validity in days (default 365 days = 1 year)
+    my $maxValidityDays = $self->conf->{sshCaCertMaxValidity} || 365;
+
+    return {
+        logo => 'certificate',
+        name => 'SSHCA',
+        id   => 'sshca',
+        html => $self->loadTemplate(
+            $req, 'sshca',
+            params => {
+                MAX_VALIDITY_DAYS => $maxValidityDays,
+                js => "$self->{p}->{staticPrefix}/common/js/sshca.js",
+            }
+        ),
+    };
+}
+
+# GET /ssh - Display the signing interface
+sub sshInterface {
+    my ( $self, $req ) = @_;
+
+    return $self->p->do( $req, [ sub { PE_OK } ] );
+}
+
+# =============================================================================
+# ROUTE HANDLERS
+# =============================================================================
+
+# GET /ssh/ca.pub - Return SSH CA public key
+sub sshCaPublicKey {
+    my ( $self, $req ) = @_;
+
+    # Get the key reference from config
+    my $keyRef = $self->conf->{sshCaKeyRef};
+    unless ($keyRef) {
+        $self->logger->error(
+            'SSH CA: No key reference configured (sshCaKeyRef)');
+        return $self->p->sendError( $req, 'SSH CA not configured', 500 );
+    }
+
+    # Get the key from LLNG keys store
+    my $keys    = $self->conf->{keys} || {};
+    my $keyData = $keys->{$keyRef};
+    unless ($keyData) {
+        $self->logger->error("SSH CA: Key '$keyRef' not found in keys store");
+        return $self->p->sendError( $req, 'SSH CA key not found', 500 );
+    }
+
+    # Get the public key
+    my $publicKey = $keyData->{keyPublic};
+    unless ($publicKey) {
+        $self->logger->error("SSH CA: No public key for '$keyRef'");
+        return $self->p->sendError( $req, 'SSH CA public key not found', 500 );
+    }
+
+    # Convert PEM public key to SSH format
+    my $sshPubKey = $self->_pemToSshPublicKey( $publicKey, $keyRef );
+    unless ($sshPubKey) {
+        $self->logger->error(
+            'SSH CA: Failed to convert public key to SSH format');
+        return $self->p->sendError( $req, 'Failed to convert key', 500 );
+    }
+
+    $self->logger->debug('SSH CA: Serving public key');
+
+    return [
+        200,
+        [
+            'Content-Type'  => 'text/plain; charset=utf-8',
+            'Cache-Control' => 'public, max-age=3600',
+        ],
+        [$sshPubKey]
+    ];
+}
+
+# GET /ssh/revoked - Return SSH Key Revocation List (KRL)
+sub sshCaKrl {
+    my ( $self, $req ) = @_;
+
+    my $krlPath = $self->conf->{sshCaKrlPath};
+    unless ($krlPath) {
+        $self->logger->error('SSH CA: No KRL path configured');
+        return $self->p->sendError( $req, 'KRL not configured', 500 );
+    }
+
+    # Read KRL file if it exists
+    if ( -f $krlPath ) {
+        open my $fh, '<:raw', $krlPath or do {
+            $self->logger->error("SSH CA: Cannot read KRL file: $!");
+            return $self->p->sendError( $req, 'Cannot read KRL', 500 );
+        };
+        local $/;
+        my $krlData = <$fh>;
+        close $fh;
+
+        $self->logger->debug('SSH CA: Serving KRL');
+
+        return [
+            200,
+            [
+                'Content-Type'  => 'application/octet-stream',
+                'Cache-Control' => 'public, max-age=300',
+            ],
+            [$krlData]
+        ];
+    }
+    else {
+        # Return empty KRL if file doesn't exist
+        $self->logger->debug(
+            'SSH CA: KRL file not found, returning empty response');
+        return [
+            200,
+            [
+                'Content-Type'  => 'application/octet-stream',
+                'Cache-Control' => 'public, max-age=300',
+            ],
+            ['']
+        ];
+    }
+}
+
+# POST /ssh/sign - Sign user's SSH public key
+sub sshCaSign {
+    my ( $self, $req ) = @_;
+
+    # Parse JSON request body
+    my $body = eval { from_json( $req->content ) };
+    if ($@) {
+        $self->logger->error("SSH CA sign: Invalid JSON body: $@");
+        return $self->_badRequest( $req, 'Invalid JSON' );
+    }
+
+    my $userPubKey = $body->{public_key};
+    unless ($userPubKey) {
+        return $self->_badRequest( $req, 'public_key parameter required' );
+    }
+
+   # Validate SSH public key format: type, base64, optional comment, single line
+   # Strict validation to prevent injection attacks
+    unless ( $userPubKey =~
+        /\A(ssh-\w+|ecdsa-sha2-\w+)\s+[A-Za-z0-9+\/]+={0,2}(?:\s+[^\r\n]*)?\z/ )
+    {
+        return $self->_badRequest( $req, 'Invalid SSH public key format' );
+    }
+
+    # Get validity from request (in days) or default to 30 days
+    my $validityDays = $body->{validity_days} || 30;
+
+    # Enforce maximum validity (in days, default 365)
+    my $maxValidityDays = $self->conf->{sshCaCertMaxValidity} || 365;
+    $validityDays = $maxValidityDays if $validityDays > $maxValidityDays;
+
+    # Convert to minutes for ssh-keygen
+    my $validityMinutes = $validityDays * 24 * 60;
+
+ # SECURITY: Always derive principals from the authenticated user's session
+ # Never trust principals from the request body to prevent impersonation attacks
+    my @principals;
+
+    # Evaluate principal sources from config (e.g., '$uid' or '$uid $mail')
+    my $principalSources = $self->conf->{sshCaPrincipalSources} || '$uid';
+
+    # Safe variable substitution without using /e to avoid eval-like behavior
+    my $principal = '';
+    my $template  = $principalSources;
+    my $pos       = 0;
+
+    while ( $template =~ /\$(\w+)/g ) {
+        my $match_start = $-[0];
+        my $match_end   = $+[0];
+
+        # Append text before the match
+        $principal .= substr( $template, $pos, $match_start - $pos );
+
+        # Get value from userData or sessionInfo
+        my $key = $1;
+        my $val = $req->userData->{$key};
+        $val = $req->sessionInfo->{$key} if !defined $val || $val eq '';
+        $val = ''                        if !defined $val;
+
+        $principal .= $val;
+        $pos = $match_end;
+    }
+
+    # Append remaining text after last match
+    $principal .= substr( $template, $pos ) if $pos < length($template);
+    $principal =~ s/^\s+|\s+$//g;    # trim
+
+    # Split on whitespace if multiple principals
+    @principals = grep { $_ ne '' } split /\s+/, $principal;
+
+  # Log warning if client tried to specify principals (potential attack attempt)
+    if ( $body->{principals} && ref $body->{principals} eq 'ARRAY' ) {
+        $self->logger->warn(
+                "SSH CA sign: Ignoring 'principals' parameter from request "
+              . "(user: "
+              . ( $req->user || 'unknown' ) . "). "
+              . "Principals are always derived from session for security." );
+    }
+
+    unless (@principals) {
+        $self->logger->error('SSH CA sign: No principals available');
+        return $self->_badRequest( $req, 'No principals available' );
+    }
+
+    # Get user info for key_id
+    my $whatToTrace = $self->conf->{whatToTrace} || 'uid';
+    my $user =
+         $req->userData->{$whatToTrace}
+      || $req->sessionInfo->{$whatToTrace}
+      || $req->userData->{uid}
+      || $req->sessionInfo->{uid}
+      || $req->user
+      || 'unknown';
+
+    # Generate serial number
+    my $serial = $self->_getNextSerial();
+
+    # Generate key_id
+    my $timestamp = time();
+    my $keyId     = sprintf( "%s\@llng-%d-%06d", $user, $timestamp, $serial );
+
+    # Sign the certificate
+    my $result =
+      $self->_signSshKey( $userPubKey, \@principals, $validityMinutes, $serial,
+        $keyId );
+
+    unless ( $result && $result->{certificate} ) {
+        $self->logger->error('SSH CA sign: Failed to sign key');
+        return $self->p->sendJSONresponse(
+            $req,
+            { error => 'Failed to sign SSH key' },
+            code => 500
+        );
+    }
+
+    # Calculate expiration time
+    my $validUntil    = time() + ( $validityMinutes * 60 );
+    my @t             = gmtime($validUntil);
+    my $validUntilISO = sprintf(
+        "%04d-%02d-%02dT%02d:%02d:%02dZ",
+        $t[5] + 1900,
+        $t[4] + 1,
+        $t[3], $t[2], $t[1], $t[0]
+    );
+
+    $self->logger->info( "SSH CA: Certificate issued for user '$user', "
+          . "principals: "
+          . join( ',', @principals ) . ", "
+          . "validity: ${validityMinutes}min, serial: $serial" );
+
+    # Store certificate in persistent session for revocation tracking
+    $self->_storeCertificate(
+        $req,
+        serial     => $serial,
+        key_id     => $keyId,
+        user       => $user,
+        principals => \@principals,
+        issued_at  => $timestamp,
+        expires_at => $validUntil,
+    );
+
+    # Audit log
+    $self->p->auditLog(
+        $req,
+        code       => 'SSH_CERT_ISSUED',
+        user       => $user,
+        message    => "SSH certificate issued for user '$user'",
+        principals => \@principals,
+        serial     => $serial,
+        key_id     => $keyId,
+        validity   => $validityMinutes,
+    );
+
+    return $self->p->sendJSONresponse(
+        $req,
+        {
+            certificate => $result->{certificate},
+            serial      => $serial,
+            valid_until => $validUntilISO,
+            principals  => \@principals,
+            key_id      => $keyId,
+        }
+    );
+}
+
+# =============================================================================
+# HELPER METHODS
+# =============================================================================
+
+sub _badRequest {
+    my ( $self, $req, $message ) = @_;
+    $message ||= 'Bad Request';
+
+    return $self->p->sendJSONresponse( $req, { error => $message },
+        code => 400 );
+}
+
+# HELPER: Get next serial number (atomic increment)
+sub _getNextSerial {
+    my ($self) = @_;
+
+    my $serialPath = $self->conf->{sshCaSerialPath}
+      || '/var/lib/lemonldap-ng/ssh/serial';
+
+    # Ensure directory exists
+    my $dir = $serialPath;
+    $dir =~ s|/[^/]+$||;
+    unless ( -d $dir ) {
+        require File::Path;
+        File::Path::make_path($dir);
+    }
+
+    # Read current serial, increment, and write back atomically using flock
+    use Fcntl qw(:flock);
+
+    my $serial = 1;
+
+  # Open file in append+read mode to ensure file is created if it doesn't exist.
+  # We then seek to beginning to read/write. This avoids a TOCTOU race when
+  # checking existence separately from opening.
+    if ( open my $fh, '+>>', $serialPath ) {
+
+        # Acquire exclusive lock to prevent race conditions
+        flock( $fh, LOCK_EX ) or do {
+            $self->logger->warn("SSH CA: Cannot lock serial file: $!");
+            close $fh;
+            return $serial;
+        };
+
+        # Seek to beginning to read current value
+        seek( $fh, 0, 0 );
+        my $current = <$fh>;
+        if ( defined $current ) {
+            chomp $current;
+            $serial = int($current) + 1 if $current =~ /^\d+$/;
+        }
+
+        # Truncate and write new serial
+        seek( $fh, 0, 0 );
+        truncate( $fh, 0 );
+        print $fh "$serial\n";
+
+        # Lock is released when file handle is closed
+        close $fh;
+    }
+    else {
+        $self->logger->warn("SSH CA: Cannot open serial file: $!");
+    }
+
+    return $serial;
+}
+
+# HELPER: Sign SSH key using ssh-keygen
+sub _signSshKey {
+    my ( $self, $userPubKey, $principals, $validityMinutes, $serial, $keyId ) =
+      @_;
+
+    require File::Temp;
+
+    # Get CA private key
+    my $keyRef = $self->conf->{sshCaKeyRef};
+    unless ($keyRef) {
+        $self->logger->error('SSH CA: No key reference configured');
+        return undef;
+    }
+
+    my $keys    = $self->conf->{keys} || {};
+    my $keyData = $keys->{$keyRef};
+    unless ( $keyData && $keyData->{keyPrivate} ) {
+        $self->logger->error(
+            "SSH CA: Key '$keyRef' not found or has no private key");
+        return undef;
+    }
+
+    # Create temp directory for key files
+    my $tmpdir = File::Temp::tempdir( CLEANUP => 1 );
+
+    # Write CA private key to temp file (convert PEM to OpenSSH format)
+    my $caKeyFile    = "$tmpdir/ca_key";
+    my $caKeyOpenSSH = $self->_pemToOpenSSHPrivateKey( $keyData->{keyPrivate} );
+    unless ($caKeyOpenSSH) {
+        $self->logger->error('SSH CA: Failed to convert CA key');
+        return undef;
+    }
+
+    open my $fh, '>', $caKeyFile or do {
+        $self->logger->error("SSH CA: Cannot write CA key: $!");
+        return undef;
+    };
+    print $fh $caKeyOpenSSH;
+    print $fh "\n" unless $caKeyOpenSSH =~ /\n$/;
+    close $fh;
+    chmod 0600, $caKeyFile;
+
+    # Write user's public key to temp file
+    my $userKeyFile = "$tmpdir/user_key.pub";
+    open $fh, '>', $userKeyFile or do {
+        $self->logger->error("SSH CA: Cannot write user key: $!");
+        return undef;
+    };
+    print $fh $userPubKey;
+    print $fh "\n" unless $userPubKey =~ /\n$/;
+    close $fh;
+
+    # Build ssh-keygen command
+    my @cmd = (
+        'ssh-keygen',
+        '-s', $caKeyFile,                   # CA key
+        '-I', $keyId,                       # Key identity
+        '-n', join( ',', @$principals ),    # Principals
+        '-V', "+${validityMinutes}m",       # Validity
+        '-z', $serial,                      # Serial number
+        $userKeyFile                        # User's public key to sign
+    );
+
+    $self->logger->debug( "SSH CA: Running: " . join( ' ', @cmd ) );
+
+    # Execute ssh-keygen
+    my $output = '';
+    my $pid    = open my $pipe, '-|';
+    if ( !defined $pid ) {
+        $self->logger->error("SSH CA: Cannot fork: $!");
+        return undef;
+    }
+    elsif ( $pid == 0 ) {
+
+        # Child process
+        open STDERR, '>&', \*STDOUT;
+        exec @cmd;
+        exit 1;
+    }
+    else {
+        # Parent process
+        local $/;
+        $output = <$pipe>;
+        close $pipe;
+    }
+
+    my $exitCode = $? >> 8;
+    if ( $exitCode != 0 ) {
+        $self->logger->error(
+            "SSH CA: ssh-keygen failed (exit $exitCode): $output");
+        return undef;
+    }
+
+    # Read the generated certificate
+    my $certFile = "$tmpdir/user_key-cert.pub";
+    unless ( -f $certFile ) {
+        $self->logger->error("SSH CA: Certificate file not created");
+        return undef;
+    }
+
+    open $fh, '<', $certFile or do {
+        $self->logger->error("SSH CA: Cannot read certificate: $!");
+        return undef;
+    };
+    my $certificate = <$fh>;
+    close $fh;
+    chomp $certificate;
+
+    return { certificate => $certificate };
+}
+
+# HELPER: Convert PEM private key to OpenSSH format
+sub _pemToOpenSSHPrivateKey {
+    my ( $self, $pemKey ) = @_;
+
+    # First, try to detect if it's already in OpenSSH format
+    if ( $pemKey =~ /^-----BEGIN OPENSSH PRIVATE KEY-----/ ) {
+        return $pemKey;
+    }
+
+    # RSA keys in traditional format - ssh-keygen can read these directly
+    if ( $pemKey =~ /BEGIN RSA PRIVATE KEY/ ) {
+        return $pemKey;
+    }
+
+    # For Ed25519 PEM keys, we need to convert to OpenSSH format
+    # because ssh-keygen cannot read Ed25519 PEM keys
+    if (   $pemKey =~ /BEGIN PRIVATE KEY/
+        || $pemKey =~ /BEGIN ED25519 PRIVATE KEY/ )
+    {
+        eval {
+            require Crypt::PK::Ed25519;
+            require MIME::Base64;
+
+            my $pk = Crypt::PK::Ed25519->new( \$pemKey );
+
+            # Get raw keys
+            my $privRaw = $pk->export_key_raw('private');    # 32 bytes
+            my $pubRaw  = $pk->export_key_raw('public');     # 32 bytes
+
+            # Build OpenSSH private key format
+            my $opensshKey =
+              $self->_buildOpenSSHPrivateKey( $privRaw, $pubRaw, '' );
+            return $opensshKey if $opensshKey;
+        };
+        if ($@) {
+            $self->logger->error("SSH CA: Failed to convert Ed25519 key: $@");
+        }
+    }
+
+    # EC keys - ssh-keygen can typically read these
+    if ( $pemKey =~ /BEGIN EC PRIVATE KEY/ ) {
+        return $pemKey;
+    }
+
+    # Fallback: return as-is and let ssh-keygen try
+    return $pemKey;
+}
+
+# HELPER: Build OpenSSH private key format from raw Ed25519 key material
+sub _buildOpenSSHPrivateKey {
+    my ( $self, $privRaw, $pubRaw, $comment ) = @_;
+
+    require MIME::Base64;
+
+    # OpenSSH private key format for Ed25519 (unencrypted):
+    # - Magic: "openssh-key-v1\0"
+    # - Cipher name: "none" (string with length prefix)
+    # - KDF name: "none" (string with length prefix)
+    # - KDF options: empty string (length 0)
+    # - Number of keys: 1 (uint32)
+    # - Public key section (length-prefixed)
+    # - Private/encrypted section (length-prefixed)
+
+    my $keytype = 'ssh-ed25519';
+
+    # Build public key blob
+    my $pubBlob = pack( 'N', length($keytype) ) . $keytype;
+    $pubBlob .= pack( 'N', length($pubRaw) ) . $pubRaw;
+
+    # Build private section
+    # Generate random check integers (must match)
+    my $checkInt = int( rand(0xFFFFFFFF) );
+
+    my $privSection = '';
+    $privSection .= pack( 'N', $checkInt );    # check-int 1
+    $privSection .= pack( 'N', $checkInt );    # check-int 2 (must match)
+
+    # Key type
+    $privSection .= pack( 'N', length($keytype) ) . $keytype;
+
+    # Public key (32 bytes)
+    $privSection .= pack( 'N', length($pubRaw) ) . $pubRaw;
+
+    # Secret buffer: private key (32 bytes) + public key (32 bytes) = 64 bytes
+    my $secretBuf = $privRaw . $pubRaw;
+    $privSection .= pack( 'N', length($secretBuf) ) . $secretBuf;
+
+    # Comment
+    $comment //= '';
+    $privSection .= pack( 'N', length($comment) ) . $comment;
+
+    # Padding to 8-byte block size (for "none" cipher)
+    my $blockSize = 8;
+    my $padLen    = $blockSize - ( length($privSection) % $blockSize );
+    $padLen = 0 if $padLen == $blockSize;
+    for my $i ( 1 .. $padLen ) {
+        $privSection .= chr($i);
+    }
+
+    # Build full key
+    my $key = '';
+
+    # Magic header
+    $key .= "openssh-key-v1\0";
+
+    # Cipher name: "none"
+    my $cipher = 'none';
+    $key .= pack( 'N', length($cipher) ) . $cipher;
+
+    # KDF name: "none"
+    my $kdf = 'none';
+    $key .= pack( 'N', length($kdf) ) . $kdf;
+
+    # KDF options: empty
+    $key .= pack( 'N', 0 );
+
+    # Number of keys
+    $key .= pack( 'N', 1 );
+
+    # Public key section
+    $key .= pack( 'N', length($pubBlob) ) . $pubBlob;
+
+    # Private section
+    $key .= pack( 'N', length($privSection) ) . $privSection;
+
+    # Encode as PEM
+    my $b64    = MIME::Base64::encode_base64( $key, '' );
+    my $pem    = "-----BEGIN OPENSSH PRIVATE KEY-----\n";
+    my $offset = 0;
+    while ( $offset < length($b64) ) {
+        $pem .= substr( $b64, $offset, 70 ) . "\n";
+        $offset += 70;
+    }
+    $pem .= "-----END OPENSSH PRIVATE KEY-----\n";
+
+    return $pem;
+}
+
+# HELPER: Convert PEM public key to SSH format
+sub _pemToSshPublicKey {
+    my ( $self, $pemKey, $comment ) = @_;
+
+    require MIME::Base64;
+
+    my $sshKey;
+
+    # Try Ed25519 first
+    eval {
+        require Crypt::PK::Ed25519;
+        my $pk     = Crypt::PK::Ed25519->new( \$pemKey );
+        my $rawKey = $pk->export_key_raw('public');
+
+        # Build SSH format: string "ssh-ed25519" + string <32 bytes key>
+        my $keyType = 'ssh-ed25519';
+        my $blob =
+            pack( 'N', length($keyType) )
+          . $keyType
+          . pack( 'N', length($rawKey) )
+          . $rawKey;
+
+        $sshKey = "$keyType " . MIME::Base64::encode_base64( $blob, '' );
+    };
+
+    # Try RSA if Ed25519 failed
+    if ( $@ || !$sshKey ) {
+        eval {
+            require Crypt::PK::RSA;
+            my $pk = Crypt::PK::RSA->new( \$pemKey );
+
+            # RSA keys can use export_key_openssh
+            $sshKey = $pk->export_key_openssh;
+        };
+    }
+
+    unless ($sshKey) {
+        $self->logger->error("SSH CA: Failed to convert key to SSH format: $@");
+        return undef;
+    }
+
+    # Add comment (SSH key has format: type base64 [comment])
+    chomp($sshKey);
+    my @parts = split /\s+/, $sshKey;
+    if ( @parts == 2 ) {
+
+        # No comment yet, add one
+        $sshKey .= " LLNG-SSH-CA-$comment";
+    }
+
+    return "$sshKey\n";
+}
+
+# =============================================================================
+# ADMIN INTERFACE METHODS
+# =============================================================================
+
+# GET /ssh/admin - Display the revocation interface
+# Access control is handled by locationRules on the portal vhost
+sub sshAdminInterface {
+    my ( $self, $req ) = @_;
+
+    return $self->p->sendHtml( $req, 'sshcaadmin' );
+}
+
+# GET /ssh/certs - List/search certificates from persistent sessions
+# Access control is handled by locationRules on the portal vhost
+sub sshCertsList {
+    my ( $self, $req ) = @_;
+
+    # Get search parameters
+    my $userFilter   = $req->param('user')   || '';
+    my $serialFilter = $req->param('serial') || '';
+    my $keyIdFilter  = $req->param('key_id') || '';
+    my $statusFilter = $req->param('status') || '';   # active, revoked, expired
+    my $limit        = int( $req->param('limit')  || 100 );
+    my $offset       = int( $req->param('offset') || 0 );
+
+    $limit = 1000 if $limit > 1000;
+
+    # Search in persistent sessions
+    my $moduleOptions = {
+        backend => $self->conf->{persistentStorage}
+          || $self->conf->{globalStorage},
+        %{
+                 $self->conf->{persistentStorageOptions}
+              || $self->conf->{globalStorageOptions}
+              || {}
+        },
+    };
+
+    my @fields = qw( _session_kind _session_uid _sshCerts );
+
+    # Search for all persistent sessions that have _sshCerts
+    my $res =
+      Lemonldap::NG::Common::Apache::Session->searchOnExpr( $moduleOptions,
+        '_session_kind', 'Persistent', @fields );
+
+    my @certs;
+    my $now = time();
+
+    for my $sessionId ( keys %{ $res || {} } ) {
+        my $session = $res->{$sessionId};
+
+        # Skip if no SSH certs
+        next unless $session->{_sshCerts};
+
+        my $user     = $session->{_session_uid} || '';
+        my $sshCerts = eval { from_json( $session->{_sshCerts} ) };
+        next if $@ || ref($sshCerts) ne 'ARRAY';
+
+        # Apply user filter at session level
+        if ( $userFilter && $user !~ /\Q$userFilter\E/i ) {
+            next;
+        }
+
+        for my $cert (@$sshCerts) {
+
+            # Apply filters
+            if ( $serialFilter && $cert->{serial} ne $serialFilter ) {
+                next;
+            }
+            if ( $keyIdFilter
+                && ( $cert->{key_id} || '' ) !~ /\Q$keyIdFilter\E/i )
+            {
+                next;
+            }
+
+            # Determine status
+            my $certStatus = 'active';
+            if ( $cert->{revoked_at} ) {
+                $certStatus = 'revoked';
+            }
+            elsif ( $cert->{expires_at} && $cert->{expires_at} < $now ) {
+                $certStatus = 'expired';
+            }
+
+            # Apply status filter
+            if ( $statusFilter && $certStatus ne $statusFilter ) {
+                next;
+            }
+
+            push @certs,
+              {
+                session_id    => $sessionId,
+                serial        => $cert->{serial},
+                key_id        => $cert->{key_id},
+                user          => $user,
+                principals    => $cert->{principals},
+                issued_at     => $cert->{issued_at},
+                expires_at    => $cert->{expires_at},
+                revoked_at    => $cert->{revoked_at},
+                revoked_by    => $cert->{revoked_by},
+                revoke_reason => $cert->{revoke_reason},
+                status        => $certStatus,
+              };
+        }
+    }
+
+    # Sort by issued_at descending (newest first)
+    @certs =
+      sort { ( $b->{issued_at} || 0 ) <=> ( $a->{issued_at} || 0 ) } @certs;
+
+    my $total = scalar @certs;
+
+    # Apply pagination
+    if ( $offset > 0 || $limit < $total ) {
+        @certs = splice( @certs, $offset, $limit );
+    }
+
+    return $self->p->sendJSONresponse(
+        $req,
+        {
+            certificates => \@certs,
+            total        => $total,
+            limit        => $limit,
+            offset       => $offset,
+        }
+    );
+}
+
+# POST /ssh/revoke - Revoke a certificate in persistent session
+# Access control is handled by locationRules on the portal vhost
+sub sshCertRevoke {
+    my ( $self, $req ) = @_;
+
+    # Parse request body
+    my $body = eval { from_json( $req->content ) };
+    if ($@) {
+        $self->logger->error("SSH revoke: Invalid JSON body: $@");
+        return $self->_badRequest( $req, 'Invalid JSON' );
+    }
+
+    my $sessionId = $body->{session_id};
+    my $serial    = $body->{serial};
+    my $reason    = $body->{reason} || '';
+
+    unless ( $sessionId && $serial ) {
+        return $self->_badRequest( $req, 'session_id and serial required' );
+    }
+
+    # Get current admin user
+    my $adminUser =
+         $req->userData->{ $self->conf->{whatToTrace} }
+      || $req->userData->{uid}
+      || $req->user
+      || 'unknown';
+
+    # Load the persistent session
+    my $moduleOptions = {
+        storageModule => $self->conf->{persistentStorage}
+          || $self->conf->{globalStorage},
+        storageModuleOptions => $self->conf->{persistentStorageOptions}
+          || $self->conf->{globalStorageOptions}
+          || {},
+    };
+
+    my $psession = Lemonldap::NG::Common::Session->new( {
+            %$moduleOptions,
+            id    => $sessionId,
+            force => 1,
+        }
+    );
+
+    unless ( $psession && !$psession->error ) {
+        return $self->p->sendJSONresponse(
+            $req,
+            { error => 'Session not found' },
+            code => 404
+        );
+    }
+
+    # Get SSH certs from session
+    my $sshCerts = [];
+    if ( $psession->data->{_sshCerts} ) {
+        $sshCerts = eval { from_json( $psession->data->{_sshCerts} ) };
+        if ($@) {
+            $self->logger->error("SSH revoke: Corrupted _sshCerts: $@");
+            return $self->p->sendJSONresponse(
+                $req,
+                { error => 'Corrupted certificate data' },
+                code => 500
+            );
+        }
+    }
+
+    # Find and update the certificate
+    my $found = 0;
+    my $user  = $psession->data->{_session_uid} || '';
+    my $keyId;
+
+    for my $cert (@$sshCerts) {
+        if ( $cert->{serial} eq $serial ) {
+            if ( $cert->{revoked_at} ) {
+                return $self->p->sendJSONresponse(
+                    $req,
+                    { error => 'Certificate already revoked' },
+                    code => 400
+                );
+            }
+            $cert->{revoked_at}    = time();
+            $cert->{revoked_by}    = $adminUser;
+            $cert->{revoke_reason} = $reason;
+            $keyId                 = $cert->{key_id};
+            $found                 = 1;
+            last;
+        }
+    }
+
+    unless ($found) {
+        return $self->p->sendJSONresponse(
+            $req,
+            { error => 'Certificate not found' },
+            code => 404
+        );
+    }
+
+    # Update session
+    $psession->update( { _sshCerts => to_json($sshCerts) } );
+
+    # Update the KRL file
+    my $krlUpdated = $self->_updateKrl($serial);
+
+    $self->logger->info( "SSH CA: Certificate revoked by '$adminUser': "
+          . "serial=$serial, key_id=$keyId, user=$user, reason=$reason" );
+
+    # Audit log
+    $self->p->auditLog(
+        $req,
+        code    => 'SSH_CERT_REVOKED',
+        user    => $user,
+        admin   => $adminUser,
+        message => "SSH certificate revoked for user '$user' by '$adminUser'",
+        serial  => $serial,
+        key_id  => $keyId,
+        reason  => $reason,
+        krl_update => $krlUpdated ? 'success' : 'failed',
+    );
+
+    return $self->p->sendJSONresponse(
+        $req,
+        {
+            result      => 1,
+            serial      => $serial,
+            key_id      => $keyId,
+            user        => $user,
+            revoked_at  => time(),
+            revoked_by  => $adminUser,
+            krl_updated => $krlUpdated ? JSON::true : JSON::false,
+        }
+    );
+}
+
+# HELPER: Store certificate in user's persistent session
+sub _storeCertificate {
+    my ( $self, $req, %args ) = @_;
+
+    # Build certificate record
+    my $certRecord = {
+        serial     => $args{serial},
+        key_id     => $args{key_id},
+        principals => join( ',', @{ $args{principals} || [] } ),
+        issued_at  => $args{issued_at},
+        expires_at => $args{expires_at},
+    };
+
+    # Get existing certificates from persistent session
+    my $sshCerts = [];
+    if ( $req->sessionInfo->{_sshCerts} ) {
+        $sshCerts = eval { from_json( $req->sessionInfo->{_sshCerts} ) };
+        if ( $@ || ref($sshCerts) ne 'ARRAY' ) {
+            $self->logger->warn("SSH CA: Corrupted _sshCerts, resetting: $@");
+            $sshCerts = [];
+        }
+    }
+
+    # Add new certificate
+    push @$sshCerts, $certRecord;
+
+    # Update persistent session
+    $self->p->updatePersistentSession( $req,
+        { _sshCerts => to_json($sshCerts) } );
+
+    $self->logger->debug(
+        "SSH CA: Stored certificate serial=$args{serial} in persistent session"
+    );
+    return 1;
+}
+
+# HELPER: Update KRL file with revoked serial
+sub _updateKrl {
+    my ( $self, $serial ) = @_;
+
+    my $krlPath = $self->conf->{sshCaKrlPath}
+      || '/var/lib/lemonldap-ng/ssh/revoked_keys';
+
+    # Ensure directory exists
+    my $dir = $krlPath;
+    $dir =~ s|/[^/]+$||;
+    unless ( -d $dir ) {
+        require File::Path;
+        File::Path::make_path($dir);
+    }
+
+    # Get CA public key for KRL
+    my $keyRef = $self->conf->{sshCaKeyRef};
+    unless ($keyRef) {
+        $self->logger->error('SSH CA: No key reference configured for KRL');
+        return 0;
+    }
+
+    my $keys    = $self->conf->{keys} || {};
+    my $keyData = $keys->{$keyRef};
+    unless ( $keyData && $keyData->{keyPublic} ) {
+        $self->logger->error("SSH CA: Key '$keyRef' not found for KRL");
+        return 0;
+    }
+
+    my $caPubKey = $self->_pemToSshPublicKey( $keyData->{keyPublic}, $keyRef );
+    unless ($caPubKey) {
+        $self->logger->error('SSH CA: Failed to convert CA public key for KRL');
+        return 0;
+    }
+
+    require File::Temp;
+    my $tmpdir = File::Temp::tempdir( CLEANUP => 1 );
+
+    # Write CA public key
+    my $caPubFile = "$tmpdir/ca.pub";
+    open my $fh, '>', $caPubFile or do {
+        $self->logger->error("SSH CA: Cannot write CA public key: $!");
+        return 0;
+    };
+    print $fh $caPubKey;
+    close $fh;
+
+    # Create KRL spec file with serial to revoke
+    my $specFile = "$tmpdir/revoke_spec";
+    open $fh, '>', $specFile or do {
+        $self->logger->error("SSH CA: Cannot write revoke spec: $!");
+        return 0;
+    };
+    print $fh "serial: $serial\n";
+    close $fh;
+
+    # Build ssh-keygen command to update KRL
+    # -k: Generate a KRL
+    # -u: Update existing KRL (only if file exists)
+    # -s: CA public key
+    # -f: KRL file
+    my @cmd = ( 'ssh-keygen', '-k' );
+
+    # Only use -u if KRL file already exists
+    push @cmd, '-u' if -f $krlPath;
+
+    push @cmd, '-s', $caPubFile, '-f', $krlPath, $specFile;
+
+    $self->logger->debug( "SSH CA: Updating KRL: " . join( ' ', @cmd ) );
+
+    # Execute ssh-keygen
+    my $output = '';
+    my $pid    = open my $pipe, '-|';
+    if ( !defined $pid ) {
+        $self->logger->error("SSH CA: Cannot fork for KRL update: $!");
+        return 0;
+    }
+    elsif ( $pid == 0 ) {
+        open STDERR, '>&', \*STDOUT;
+        exec @cmd;
+        exit 1;
+    }
+    else {
+        local $/;
+        $output = <$pipe>;
+        close $pipe;
+    }
+
+    my $exitCode = $? >> 8;
+    if ( $exitCode != 0 ) {
+        $self->logger->error(
+            "SSH CA: KRL update failed (exit $exitCode): $output");
+        return 0;
+    }
+
+    $self->logger->info("SSH CA: KRL updated with revoked serial $serial");
+    return 1;
+}
+
+1;
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/common/js/pamaccess.js
@@ -0,0 +1,63 @@
+(function () {
+  'use strict';
+
+  (function () {
+    $(window).on("load", function () {
+      var form = document.getElementById('pamTokenForm');
+      if (!form) return;
+      var resultDiv = document.getElementById('pamTokenResult');
+      var errorDiv = document.getElementById('pamTokenError');
+      var tokenInput = document.getElementById('pamToken');
+      var loginSpan = document.getElementById('pamLogin');
+      var expiresSpan = document.getElementById('pamExpiresIn');
+      var copyBtn = document.getElementById('copyPamToken');
+      var errorMsg = document.getElementById('pamErrorMessage');
+      form.addEventListener('submit', function (e) {
+        e.preventDefault();
+        resultDiv.classList.add('d-none');
+        errorDiv.classList.add('d-none');
+        var duration = document.getElementById('pamDuration').value;
+        $.ajax({
+          type: "POST",
+          url: scriptname + 'pam',
+          data: {
+            duration: duration
+          },
+          dataType: "json",
+          success: function success(data) {
+            if (data.error) {
+              errorMsg.textContent = data.error;
+              errorDiv.classList.remove('d-none');
+            } else {
+              tokenInput.value = data.token;
+              loginSpan.textContent = data.login;
+              var minutes = Math.floor(data.expires_in / 60);
+              var seconds = data.expires_in % 60;
+              expiresSpan.textContent = minutes + ' min ' + (seconds > 0 ? seconds + ' sec' : '');
+              resultDiv.classList.remove('d-none');
+            }
+          },
+          error: function error(xhr, status, _error) {
+            errorMsg.textContent = _error || status;
+            errorDiv.classList.remove('d-none');
+          }
+        });
+      });
+
+      // Copy button
+      if (copyBtn) {
+        copyBtn.addEventListener('click', function () {
+          tokenInput.select();
+          tokenInput.setSelectionRange(0, 99999);
+          navigator.clipboard.writeText(tokenInput.value).then(function () {
+            copyBtn.innerHTML = '<span class="fa fa-check"></span>';
+            setTimeout(function () {
+              copyBtn.innerHTML = '<span class="fa fa-copy"></span>';
+            }, 2000);
+          });
+        });
+      }
+    });
+  })();
+
+})();
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/common/js/sshca.js
@@ -0,0 +1,99 @@
+(function () {
+  'use strict';
+
+  (function () {
+    $(window).on("load", function () {
+      var form = document.getElementById('sshCaForm');
+      if (!form) return;
+      var resultDiv = document.getElementById('sshCaResult');
+      var errorDiv = document.getElementById('sshCaError');
+      var certTextarea = document.getElementById('sshCertificate');
+      var keyIdSpan = document.getElementById('sshKeyId');
+      var principalsSpan = document.getElementById('sshPrincipals');
+      var validUntilSpan = document.getElementById('sshValidUntil');
+      var copyBtn = document.getElementById('copySshCert');
+      var errorMsg = document.getElementById('sshCaErrorMessage');
+      var validitySelect = document.getElementById('sshValidity');
+
+      // Filter validity options based on max validity
+      if (validitySelect) {
+        var maxValidity = parseInt(validitySelect.dataset.maxValidity) || 365;
+        var options = validitySelect.querySelectorAll('option');
+        var lastValidOption = null;
+        options.forEach(function (option) {
+          var value = parseInt(option.value);
+          if (value > maxValidity) {
+            option.remove();
+          } else {
+            lastValidOption = option;
+          }
+        });
+
+        // Select the highest valid option if the default was removed
+        var selectedOption = validitySelect.querySelector('option[selected]');
+        if (!selectedOption && lastValidOption) {
+          lastValidOption.selected = true;
+        }
+      }
+      form.addEventListener('submit', function (e) {
+        e.preventDefault();
+        resultDiv.classList.add('d-none');
+        errorDiv.classList.add('d-none');
+        var publicKey = document.getElementById('sshPublicKey').value.trim();
+        var validityDays = parseInt(validitySelect.value);
+        if (!publicKey) {
+          errorMsg.textContent = 'Please paste your SSH public key';
+          errorDiv.classList.remove('d-none');
+          return;
+        }
+        $.ajax({
+          type: "POST",
+          url: scriptname + 'ssh/sign',
+          contentType: "application/json",
+          data: JSON.stringify({
+            public_key: publicKey,
+            validity_days: validityDays
+          }),
+          dataType: "json",
+          success: function success(data) {
+            if (data.error) {
+              errorMsg.textContent = data.error;
+              errorDiv.classList.remove('d-none');
+            } else {
+              certTextarea.value = data.certificate;
+              keyIdSpan.textContent = data.key_id;
+              principalsSpan.textContent = data.principals.join(', ');
+              validUntilSpan.textContent = data.valid_until;
+              resultDiv.classList.remove('d-none');
+            }
+          },
+          error: function error(xhr, status, _error) {
+            var msg = _error || status;
+            try {
+              var resp = JSON.parse(xhr.responseText);
+              if (resp.error) msg = resp.error;
+            } catch (e) {}
+            errorMsg.textContent = msg;
+            errorDiv.classList.remove('d-none');
+          }
+        });
+      });
+
+      // Copy button
+      if (copyBtn) {
+        copyBtn.addEventListener('click', function () {
+          certTextarea.select();
+          certTextarea.setSelectionRange(0, 99999);
+          navigator.clipboard.writeText(certTextarea.value).then(function () {
+            var originalHtml = copyBtn.innerHTML;
+            copyBtn.innerHTML = '<span class="fa fa-check"></span> Copied!';
+            setTimeout(function () {
+              copyBtn.innerHTML = originalHtml;
+            }, 2000);
+          });
+        });
+      }
+    });
+  })();
+
+})();
new file mode 100644
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/common/js/sshcaadmin.js
@@ -0,0 +1,280 @@
+(function () {
+  'use strict';
+
+  (function () {
+
+    var currentPage = 0;
+    var pageSize = 20;
+    var totalCerts = 0;
+    var revokeModal = null;
+    var alertToast = null;
+
+    // Escape HTML to prevent XSS
+    function escapeHtml(str) {
+      if (str === null || str === undefined) return '';
+      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
+    }
+
+    // Get the base URL (script name without trailing slash)
+    function getBaseUrl() {
+      var path = window.location.pathname;
+      // Remove /ssh/admin from the path to get the base
+      return path.replace(/\/ssh\/admin\/?$/, '');
+    }
+
+    // Format timestamp to readable date
+    function formatDate(timestamp) {
+      if (!timestamp) return '-';
+      var d = new Date(timestamp * 1000);
+      return d.toLocaleString();
+    }
+
+    // Get status badge HTML
+    function getStatusBadge(status) {
+      var badgeClass = 'bg-secondary';
+      var text = status;
+      switch (status) {
+        case 'active':
+          badgeClass = 'bg-success';
+          break;
+        case 'expired':
+          badgeClass = 'bg-secondary';
+          break;
+        case 'revoked':
+          badgeClass = 'bg-danger';
+          break;
+      }
+      return '<span class="badge ' + badgeClass + '">' + text + '</span>';
+    }
+
+    // Show toast notification
+    function showToast(message, type) {
+      var toastEl = document.getElementById('alertToast');
+      var toastIcon = document.getElementById('toastIcon');
+      var toastTitle = document.getElementById('toastTitle');
+      var toastMessage = document.getElementById('toastMessage');
+      toastMessage.textContent = message;
+      if (type === 'success') {
+        toastIcon.className = 'fa fa-check-circle me-2 text-success';
+        toastTitle.textContent = 'Success';
+      } else if (type === 'error') {
+        toastIcon.className = 'fa fa-exclamation-circle me-2 text-danger';
+        toastTitle.textContent = 'Error';
+      } else {
+        toastIcon.className = 'fa fa-info-circle me-2 text-info';
+        toastTitle.textContent = 'Info';
+      }
+      if (!alertToast) {
+        alertToast = new bootstrap.Toast(toastEl);
+      }
+      alertToast.show();
+    }
+
+    // Load certificates from API
+    function loadCertificates(page) {
+      currentPage = page || 0;
+      var offset = currentPage * pageSize;
+      var params = new URLSearchParams();
+      params.set('limit', pageSize);
+      params.set('offset', offset);
+      var user = document.getElementById('searchUser').value.trim();
+      var serial = document.getElementById('searchSerial').value.trim();
+      var keyId = document.getElementById('searchKeyId').value.trim();
+      var status = document.getElementById('searchStatus').value;
+      if (user) params.set('user', user);
+      if (serial) params.set('serial', serial);
+      if (keyId) params.set('key_id', keyId);
+      if (status) params.set('status', status);
+      var tableBody = document.getElementById('certsTable');
+      var loadingRow = document.getElementById('loadingRow');
+      var noResultsRow = document.getElementById('noResultsRow');
+      var searchPromptRow = document.getElementById('searchPromptRow');
+
+      // Show loading
+      loadingRow.classList.remove('d-none');
+      noResultsRow.classList.add('d-none');
+      if (searchPromptRow) searchPromptRow.classList.add('d-none');
+
+      // Remove existing cert rows
+      var existingRows = tableBody.querySelectorAll('.cert-row');
+      existingRows.forEach(function (row) {
+        row.remove();
+      });
+      var baseUrl = getBaseUrl();
+      $.ajax({
+        type: 'GET',
+        url: baseUrl + '/ssh/certs?' + params.toString(),
+        dataType: 'json',
+        success: function success(data) {
+          loadingRow.classList.add('d-none');
+          totalCerts = data.total || 0;
+          document.getElementById('resultCount').textContent = totalCerts;
+          if (!data.certificates || data.certificates.length === 0) {
+            noResultsRow.classList.remove('d-none');
+            updatePagination();
+            return;
+          }
+          noResultsRow.classList.add('d-none');
+          data.certificates.forEach(function (cert) {
+            var row = document.createElement('tr');
+            row.className = 'cert-row';
+            row.innerHTML = '<td>' + escapeHtml(cert.serial || '-') + '</td>' + '<td>' + escapeHtml(cert.user || '-') + '</td>' + '<td><code>' + escapeHtml(cert.principals || '-') + '</code></td>' + '<td>' + escapeHtml(formatDate(cert.issued_at)) + '</td>' + '<td>' + escapeHtml(formatDate(cert.expires_at)) + '</td>' + '<td>' + getStatusBadge(cert.status) + '</td>' + '<td>' + getActionButtons(cert) + '</td>';
+            tableBody.appendChild(row);
+          });
+
+          // Bind revoke buttons
+          tableBody.querySelectorAll('.btn-revoke').forEach(function (btn) {
+            btn.addEventListener('click', function (e) {
+              e.preventDefault();
+              showRevokeModal(this.dataset.sessionId, this.dataset.serial, this.dataset.user, this.dataset.keyId);
+            });
+          });
+          updatePagination();
+        },
+        error: function error(xhr, status, _error) {
+          loadingRow.classList.add('d-none');
+          noResultsRow.classList.remove('d-none');
+          noResultsRow.querySelector('td').textContent = 'Error loading certificates: ' + (_error || status);
+          showToast('Failed to load certificates', 'error');
+        }
+      });
+    }
+
+    // Get action buttons HTML for a certificate
+    function getActionButtons(cert) {
+      if (cert.status === 'revoked') {
+        return '<span class="text-muted" title="Revoked by ' + escapeHtml(cert.revoked_by || 'unknown') + ' at ' + escapeHtml(formatDate(cert.revoked_at)) + '">' + '<span class="fa fa-ban"></span> Revoked</span>';
+      }
+      return '<button class="btn btn-sm btn-outline-danger btn-revoke" ' + 'data-session-id="' + escapeHtml(cert.session_id) + '" ' + 'data-serial="' + escapeHtml(cert.serial || '') + '" ' + 'data-user="' + escapeHtml(cert.user || '') + '" ' + 'data-key-id="' + escapeHtml(cert.key_id || '') + '">' + '<span class="fa fa-ban"></span> Revoke</button>';
+    }
+
+    // Update pagination
+    function updatePagination() {
+      var pagination = document.getElementById('pagination');
+      pagination.innerHTML = '';
+      var totalPages = Math.ceil(totalCerts / pageSize);
+      if (totalPages <= 1) return;
+
+      // Previous button
+      var prevLi = document.createElement('li');
+      prevLi.className = 'page-item' + (currentPage === 0 ? ' disabled' : '');
+      prevLi.innerHTML = '<a class="page-link" href="#" data-page="' + (currentPage - 1) + '">&laquo;</a>';
+      pagination.appendChild(prevLi);
+
+      // Page numbers
+      var startPage = Math.max(0, currentPage - 2);
+      var endPage = Math.min(totalPages - 1, currentPage + 2);
+      for (var i = startPage; i <= endPage; i++) {
+        var li = document.createElement('li');
+        li.className = 'page-item' + (i === currentPage ? ' active' : '');
+        li.innerHTML = '<a class="page-link" href="#" data-page="' + i + '">' + (i + 1) + '</a>';
+        pagination.appendChild(li);
+      }
+
+      // Next button
+      var nextLi = document.createElement('li');
+      nextLi.className = 'page-item' + (currentPage >= totalPages - 1 ? ' disabled' : '');
+      nextLi.innerHTML = '<a class="page-link" href="#" data-page="' + (currentPage + 1) + '">&raquo;</a>';
+      pagination.appendChild(nextLi);
+
+      // Bind click handlers
+      pagination.querySelectorAll('.page-link').forEach(function (link) {
+        link.addEventListener('click', function (e) {
+          e.preventDefault();
+          var page = parseInt(this.dataset.page);
+          if (!isNaN(page) && page >= 0 && page < totalPages) {
+            loadCertificates(page);
+          }
+        });
+      });
+    }
+
+    // Show revoke modal
+    function showRevokeModal(sessionId, serial, user, keyId) {
+      document.getElementById('revokeSessionId').value = sessionId;
+      document.getElementById('revokeSerialInput').value = serial;
+      document.getElementById('revokeSerial').textContent = serial;
+      document.getElementById('revokeUser').textContent = user;
+      document.getElementById('revokeKeyId').textContent = keyId;
+      document.getElementById('revokeReason').value = '';
+      if (!revokeModal) {
+        revokeModal = new bootstrap.Modal(document.getElementById('revokeModal'));
+      }
+      revokeModal.show();
+    }
+
+    // Perform revocation
+    function revokeCertificate() {
+      var sessionId = document.getElementById('revokeSessionId').value;
+      var serial = document.getElementById('revokeSerialInput').value;
+      var reason = document.getElementById('revokeReason').value.trim();
+      var baseUrl = getBaseUrl();
+      $.ajax({
+        type: 'POST',
+        url: baseUrl + '/ssh/revoke',
+        contentType: 'application/json',
+        data: JSON.stringify({
+          session_id: sessionId,
+          serial: serial,
+          reason: reason
+        }),
+        dataType: 'json',
+        success: function success(data) {
+          revokeModal.hide();
+          if (data.result) {
+            showToast('Certificate revoked successfully', 'success');
+            loadCertificates(currentPage);
+          } else {
+            showToast(data.error || 'Failed to revoke certificate', 'error');
+          }
+        },
+        error: function error(xhr, status, _error2) {
+          revokeModal.hide();
+          var msg = _error2 || status;
+          try {
+            var resp = JSON.parse(xhr.responseText);
+            if (resp.error) msg = resp.error;
+          } catch (e) {}
+          showToast('Failed to revoke certificate: ' + msg, 'error');
+        }
+      });
+    }
+
+    // Initialize on page load
+    $(window).on('load', function () {
+      // Search form submit
+      document.getElementById('searchForm').addEventListener('submit', function (e) {
+        e.preventDefault();
+        loadCertificates(0);
+      });
+
+      // Reset search - clear form and show search prompt
+      document.getElementById('resetSearch').addEventListener('click', function () {
+        document.getElementById('searchUser').value = '';
+        document.getElementById('searchSerial').value = '';
+        document.getElementById('searchKeyId').value = '';
+        document.getElementById('searchStatus').value = '';
+        // Clear results
+        var tableBody = document.getElementById('certsTable');
+        var existingRows = tableBody.querySelectorAll('.cert-row');
+        existingRows.forEach(function (row) {
+          row.remove();
+        });
+        document.getElementById('loadingRow').classList.add('d-none');
+        document.getElementById('noResultsRow').classList.add('d-none');
+        var searchPromptRow = document.getElementById('searchPromptRow');
+        if (searchPromptRow) searchPromptRow.classList.remove('d-none');
+        document.getElementById('resultCount').textContent = '0';
+        document.getElementById('pagination').innerHTML = '';
+        totalCerts = 0;
+      });
+
+      // Confirm revoke button
+      document.getElementById('confirmRevoke').addEventListener('click', revokeCertificate);
+
+      // No initial load - wait for user to search
+      document.getElementById('loadingRow').classList.add('d-none');
+    });
+  })();
+
+})();
new file mode 100644
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/ar.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/ar.json
@@ -124,6 +124,7 @@
 "authLevel":"  ",
 "authPortal":"  ",
 "authRemaining":" s       !",
+"authorize":"Authorize",
 "autoAccept":"   30 ",
 "autoGlobalLogout":"   30 ",
 "back2CasUrl":"              ",
@@ -149,6 +150,7 @@
 "click2Reset":"       ",
 "clickHere":"  ",
 "clickOnYubikey":"  Yubikey  ",
+"clientId":"Client ID",
 "close":"",
 "closeSSO":"    ()",
 "code":"",
@@ -166,6 +168,13 @@
 "currentPwd":"  ",
 "date":"",
 "decryptCipheredValue":"   ",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"     ",
 "enterExt2fCode":"   .  ",
 "enterMail2fCode":"    .  ",
@@ -182,6 +191,7 @@
 "firstName":" ",
 "forbidden":" ",
 "forgotPwd":"  ",
+"generatePamToken":"Generate Token",
 "generatePwd":"   ",
 "generic":" ",
 "generic2fFormatError":"     ",
@@ -266,6 +276,15 @@
 "openidPA":"     ",
 "openidRpns":" %s     ",
 "otherSessions":"  ",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":" ",
 "password2f":" ",
 "passwordCompromised":"           ",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"  ",
 "rename":"Rename",
 "renewSession":" ",
+"requestedScope":"Requested scope",
 "resendCode":"  ",
 "resendConfirmMail":"     ",
 "resendTooSoon":"       ",
@@ -354,6 +374,8 @@
 "upgradeSession":" ",
 "useYubikey":"    ",
 "user":"",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":" ",
 "value":"",
 "verify":"",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/de.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/de.json
@@ -124,6 +124,7 @@
 "authLevel":"Authentication level",
 "authPortal":"Authentifizierungsportal",
 "authRemaining":"%sverbleibende Authentifizierungen, bitte Passwort ndern!",
+"authorize":"Authorize",
 "autoAccept":"Automatisch in 30 Sekunden annehmen",
 "autoGlobalLogout":"Automatically global logout in 30 seconds",
 "back2CasUrl":"Die Anwendung, von der Sie sich gerade abgemeldet haben, hat einen Link bereitgestellt, dem Sie folgen sollten",
@@ -149,6 +150,7 @@
 "click2Reset":"Hier klicken, um Ihr Passwort zurckzusetzen.",
 "clickHere":"Bitte hier klicken",
 "clickOnYubikey":"Klicke auf deinen Yubikey",
+"clientId":"Client ID",
 "close":"Close",
 "closeSSO":"Schliee deine SSO-Sitzung",
 "code":"Code",
@@ -166,6 +168,13 @@
 "currentPwd":"Aktuelles Passwort",
 "date":"Datum",
 "decryptCipheredValue":"Decrypt a ciphered value",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Bitte geben deine Zugangsdaten ein",
 "enterExt2fCode":"Ein Code wurde an dich gesendet. Bitte gebe diesen ein",
 "enterMail2fCode":"A code has been sent to your email address. Please enter it",
@@ -182,6 +191,7 @@
 "firstName":"Vorname",
 "forbidden":"Access FORBIDDEN",
 "forgotPwd":"Passwort vergessen ?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Passwort automatisch generieren",
 "generic":"Contact information",
 "generic2fFormatError":"Your contact information does not match the required format",
@@ -266,6 +276,15 @@
 "openidPA":"Die Datennutzungsrichtlinie ist verfgbar unter",
 "openidRpns":"Der fr den Verbund angeforderte Parameter %s ist nicht verfgbar",
 "otherSessions":"Andere aktive Sitzungen",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Passwort",
 "password2f":"Passwort",
 "passwordCompromised":"Not found in a compromised password database",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Andere Sitzungen lschen",
 "rename":"Rename",
 "renewSession":"Renew session",
+"requestedScope":"Requested scope",
 "resendCode":"Re-send code",
 "resendConfirmMail":"Besttigungsmail erneuert senden ?",
 "resendTooSoon":"Please wait a little longer before trying to re-send the code",
@@ -354,6 +374,8 @@
 "upgradeSession":"Upgrade session",
 "useYubikey":"Benutze deinen Yubikey",
 "user":"Benutzer",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Validation date",
 "value":"Value",
 "verify":"Verify",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/en.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/en.json
@@ -124,6 +124,7 @@
 "authLevel":"Authentication level",
 "authPortal":"Authentication portal",
 "authRemaining":"%s authentications remaining, change your password!",
+"authorize":"Authorize",
 "autoAccept":"Automatically accept in 30 seconds",
 "autoGlobalLogout":"Automatically global logout in 30 seconds",
 "back2CasUrl":"The application you just logged out of has provided a link it would like you to follow",
@@ -149,6 +150,7 @@
 "click2Reset":"Click here to reset your password",
 "clickHere":"Please click here",
 "clickOnYubikey":"Click on your Yubikey",
+"clientId":"Client ID",
 "close":"Close",
 "closeSSO":"Close your SSO session",
 "code":"Code",
@@ -166,6 +168,13 @@
 "currentPwd":"Current password",
 "date":"Date",
 "decryptCipheredValue":"Decrypt a ciphered value",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Please enter your credentials",
 "enterExt2fCode":"A code has been sent to you. Please enter it",
 "enterMail2fCode":"A code has been sent to your email address. Please enter it",
@@ -182,6 +191,7 @@
 "firstName":"First name",
 "forbidden":"Access FORBIDDEN",
 "forgotPwd":"Forgot your password?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Generate the password automatically",
 "generic":"Contact information",
 "generic2fFormatError":"Your contact information does not match the required format",
@@ -266,6 +276,15 @@
 "openidPA":"Data usage policy is available at",
 "openidRpns":"Parameter %s requested for federation isn't available",
 "otherSessions":"Other active sessions",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Password",
 "password2f":"Password",
 "passwordCompromised":"Not found in a compromised password database",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Remove other sessions",
 "rename":"Rename",
 "renewSession":"Renew session",
+"requestedScope":"Requested scope",
 "resendCode":"Re-send code",
 "resendConfirmMail":"Resend confirmation mail?",
 "resendTooSoon":"Please wait a little longer before trying to re-send the code",
@@ -354,6 +374,8 @@
 "upgradeSession":"Upgrade session",
 "useYubikey":"use your Yubikey",
 "user":"User",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Validation date",
 "value":"Value",
 "verify":"Verify",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/es.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/es.json
@@ -124,6 +124,7 @@
 "authLevel":"Nivel de autentificacin",
 "authPortal":"Portal de autenticacin",
 "authRemaining":"%s autenticaciones restantes, cambie su contrasea!",
+"authorize":"Authorize",
 "autoAccept":"Aceptar automticamente en 30 segundos ",
 "autoGlobalLogout":"Desconexin global automtica en 30 segundos",
 "back2CasUrl":"La aplicacin de la cual se acaba de desconectar le ha enviado un enlace y le gustara que lo siguiese",
@@ -149,6 +150,7 @@
 "click2Reset":"Pulse aqu para restaurar el password",
 "clickHere":"Por favor haga clic aqu",
 "clickOnYubikey":"Haga clic en su Yubikey",
+"clientId":"Client ID",
 "close":"Close",
 "closeSSO":"Cierre su sesin SSO",
 "code":"Cdigo",
@@ -166,6 +168,13 @@
 "currentPwd":"Contrasea actual",
 "date":"Fecha",
 "decryptCipheredValue":"Desencriptar un valor cifrado",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Por favor ingrese sus credenciales",
 "enterExt2fCode":"Un cdigo le ha sido enviado. Por favor ingrselo ",
 "enterMail2fCode":"Un cdigo le ha sido enviado a direccin de e-mail. Por favor ingrselo",
@@ -182,6 +191,7 @@
 "firstName":"Nombre",
 "forbidden":"Acceso DENEGADO",
 "forgotPwd":"Contrasea olvidada?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Generar la contrasea automticamente",
 "generic":"Contact information",
 "generic2fFormatError":"Your contact information does not match the required format",
@@ -266,6 +276,15 @@
 "openidPA":"La poltica de uso de datos est disponible en",
 "openidRpns":"El parmetro %s solicitado por la agrupacin no est disponible",
 "otherSessions":"Otras sesiones activas",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Contrasea",
 "password2f":"Contrasea",
 "passwordCompromised":"Not found in a compromised password database",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Suprimir las otras sesiones",
 "rename":"Rename",
 "renewSession":"Renew session",
+"requestedScope":"Requested scope",
 "resendCode":"Re-send code",
 "resendConfirmMail":"Reenviar e-mail de confirmacin?",
 "resendTooSoon":"Please wait a little longer before trying to re-send the code",
@@ -354,6 +374,8 @@
 "upgradeSession":"Actualizar la sesin",
 "useYubikey":"utilice su Yubikey",
 "user":"Usuario",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Validation date",
 "value":"Valor",
 "verify":"Verificar",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/fi.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/fi.json
@@ -124,6 +124,7 @@
 "authLevel":"Tunnistautumistaso",
 "authPortal":"Todentautumisportaali",
 "authRemaining":"%s todentautumista jljell, vaihda salasanasi!",
+"authorize":"Authorize",
 "autoAccept":"Hyvksytn automaattisesti 30 sekunnissa",
 "autoGlobalLogout":"Kirjaudutaan automaattisesti ulos kaikista istunnoista 30 sekunnissa",
 "back2CasUrl":"Sovellus, josta juuri kirjauduit ulos, tarjosi linkin, jota se haluaisi sinun seuraavan",
@@ -149,6 +150,7 @@
 "click2Reset":"Napsauta tst nollataksesi salasanasi",
 "clickHere":"Napsauta tst",
 "clickOnYubikey":"Kosketa Yubikeytsi",
+"clientId":"Client ID",
 "close":"Sulje",
 "closeSSO":"Sulje kertakirjautumisistuntosi",
 "code":"Koodi",
@@ -166,6 +168,13 @@
 "currentPwd":"Nykyinen salasana",
 "date":"Pivmr",
 "decryptCipheredValue":"Pura koodattu arvo",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Anna tunnistautumistietosi",
 "enterExt2fCode":"Koodi on lhetetty sinulle. Ole hyv ja anna se",
 "enterMail2fCode":"Koodi on lhetetty shkpostiisi. Ole hyv ja anna se",
@@ -182,6 +191,7 @@
 "firstName":"Etunimi",
 "forbidden":"Psy KIELLETTY",
 "forgotPwd":"Unohditko salasanasi?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Luo salasana automaattisesti",
 "generic":"Yhteystieto",
 "generic2fFormatError":"Yhteystietosi eivt vastaa vaadittua muotoa",
@@ -266,6 +276,15 @@
 "openidPA":"Tietosuojakytnne on saatavissa osoitteesta",
 "openidRpns":"Luottamusverkostoa varten pyydetty parametri %s ei ole saatavilla",
 "otherSessions":"Muut aktiiviset istunnot",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Salasana",
 "password2f":"Salasana",
 "passwordCompromised":"Ei lydy vaarantuneiden salasanojen tietokannasta",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Poista muut istunnot",
 "rename":"Rename",
 "renewSession":"Uudista istunto",
+"requestedScope":"Requested scope",
 "resendCode":"Lhet koodi uudestaan",
 "resendConfirmMail":"Lhet vahvistusshkposti uudestaan?",
 "resendTooSoon":"Ole hyv ja odota vhn pidempn ennen kuin yritt lhett koodia uudestaan",
@@ -354,6 +374,8 @@
 "upgradeSession":"Ylenn istunto",
 "useYubikey":"Kyt Yubikeyt",
 "user":"Kyttj",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Vahvistuspivmr",
 "value":"Arvo",
 "verify":"Vahvista",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/fr.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/fr.json
@@ -124,6 +124,7 @@
 "authLevel":"Niveau d'authentification",
 "authPortal":"Portail d'authentification",
 "authRemaining":"%s authentifications restantes, changez votre mot de passe !",
+"authorize":"Autoriser",
 "autoAccept":"Acceptation automatique dans 30 secondes",
 "autoGlobalLogout":"Dconnexion globale automatique dans 30 secondes",
 "back2CasUrl":"Le service duquel vous arrivez a fourni un lien que vous tes invit  suivre",
@@ -149,6 +150,7 @@
 "click2Reset":"Cliquez ici pour rinitialiser votre mot de passe",
 "clickHere":"Cliquez ici",
 "clickOnYubikey":"Cliquez sur votre Yubikey",
+"clientId":"ID Client",
 "close":"Fermer",
 "closeSSO":"Fermer votre Session SSO",
 "code":"Code",
@@ -166,6 +168,13 @@
 "currentPwd":"Mot de passe actuel",
 "date":"Date",
 "decryptCipheredValue":"Dcoder une valeur chiffre",
+"deny":"Refuser",
+"deviceApproved":"Appareil approuv",
+"deviceApprovedMsg":"L'appareil a t autoris. Vous pouvez fermer cette fentre.",
+"deviceAuthorization":"Autorisation d'appareil",
+"deviceAuthorizationMsg":"Entrez le code affich sur votre appareil pour l'autoriser.",
+"deviceDenied":"Appareil refus",
+"deviceDeniedMsg":"L'autorisation de l'appareil a t refuse. Vous pouvez fermer cette fentre.",
 "enterCred":"Merci de vous authentifier",
 "enterExt2fCode":"Un code vous a t envoy, entrez-le ici",
 "enterMail2fCode":"Un code vous a t envoy par mail, entrez-le ici",
@@ -182,6 +191,7 @@
 "firstName":"Prnom",
 "forbidden":"Accs INTERDIT",
 "forgotPwd":"Mot de passe oubli ?",
+"generatePamToken":"Gnrer un token",
 "generatePwd":"Gnrer le mot de passe automatiquement",
 "generic":"Information de contact",
 "generic2fFormatError":"Vos informations de contact ne correspondent pas au format attendu",
@@ -266,6 +276,15 @@
 "openidPA":"La politique d'utilisation des donnes est disponible ici",
 "openidRpns":"Le paramtre %s exig pour la fdration n'est pas disponible",
 "otherSessions":"Autres sessions ouvertes",
+"pamAccessInfo":"Gnrez un token temporaire  utiliser comme mot de passe pour SSH ou d'autres services PAM.",
+"pamAccessTitle":"Token d'accs PAM",
+"pamExpiresIn":"Expire dans",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Utilisez ce token comme mot de passe lors de la connexion via SSH ou d'autres services PAM.",
+"pamLogin":"Identifiant",
+"pamTokenDuration":"Dure de validit",
+"pamTokenError":"chec de la gnration du token",
+"pamTokenGenerated":"Votre token temporaire",
 "password":"Mot de passe",
 "password2f":"Mot de passe",
 "passwordCompromised":"Absent d'une base de mots de passe compromis",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Fermer les autres sessions",
 "rename":"Renommer",
 "renewSession":"Renouveler la session",
+"requestedScope":"Scope demand",
 "resendCode":"Renvoyer le code",
 "resendConfirmMail":"Renvoyer le mail de confirmation ?",
 "resendTooSoon":"Veuillez patienter encore un peu avant de demander la retransmission du code",
@@ -354,6 +374,8 @@
 "upgradeSession":"Se rauthentifier",
 "useYubikey":"Utilisez votre Yubikey",
 "user":"Utilisateur",
+"userCode":"Code de l'appareil",
+"userCodeHelp":"Entrez le code  8 caractres affich sur votre appareil",
 "validationDate":"Date de validation",
 "value":"Valeur",
 "verify":"Vrifier",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/he.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/he.json
@@ -124,6 +124,7 @@
 "authLevel":" ",
 "authPortal":" ",
 "authRemaining":"%s   ,     !",
+"authorize":"Authorize",
 "autoAccept":"   30 ",
 "autoGlobalLogout":"    30 ",
 "back2CasUrl":"         ",
@@ -149,6 +150,7 @@
 "click2Reset":"    ",
 "clickHere":"  ",
 "clickOnYubikey":"   Yubikey ",
+"clientId":"Client ID",
 "close":"",
 "closeSSO":"  SSO ",
 "code":"",
@@ -166,6 +168,13 @@
 "currentPwd":" ",
 "date":"",
 "decryptCipheredValue":"  ",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"     ",
 "enterExt2fCode":"  .   ",
 "enterMail2fCode":"    .   ",
@@ -182,6 +191,7 @@
 "firstName":" ",
 "forbidden":" ",
 "forgotPwd":"   ?",
+"generatePamToken":"Generate Token",
 "generatePwd":"  ",
 "generic":"  ",
 "generic2fFormatError":"      ",
@@ -266,6 +276,15 @@
 "openidPA":"    ",
 "openidRpns":" %s    ",
 "otherSessions":"  ",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"",
 "password2f":"",
 "passwordCompromised":"     ",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"  ",
 "rename":"Rename",
 "renewSession":" ",
+"requestedScope":"Requested scope",
 "resendCode":"   ",
 "resendConfirmMail":"    ?",
 "resendTooSoon":"         ",
@@ -354,6 +374,8 @@
 "upgradeSession":" ",
 "useYubikey":" Yubikey ",
 "user":"",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":" ",
 "value":"",
 "verify":"",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/it.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/it.json
@@ -124,6 +124,7 @@
 "authLevel":"Livello di autenticazione",
 "authPortal":"Portale di autenticazione",
 "authRemaining":"Rimangono ancora %s autenticazioni, modifica la password!",
+"authorize":"Authorize",
 "autoAccept":"Accetta automaticamente in 30 secondi",
 "autoGlobalLogout":"Logout globale automatico in 30 secondi",
 "back2CasUrl":"L'applicazione dalla quale ti sei appena sconnesso ha fornito un link che dovresti seguire",
@@ -149,6 +150,7 @@
 "click2Reset":"Clicca qui per reimpostare la password",
 "clickHere":"Per favore clicca qui",
 "clickOnYubikey":"Clicca sulla tua Yubikey",
+"clientId":"Client ID",
 "close":"Close",
 "closeSSO":"Chiudi la sessione SSO",
 "code":"Codice",
@@ -166,6 +168,13 @@
 "currentPwd":"Password attuale",
 "date":"Data",
 "decryptCipheredValue":"Decripta un valore cifrato",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Inserisci le tue credenziali",
 "enterExt2fCode":"Un codice vi  stato inviato. Inseritelo",
 "enterMail2fCode":"Un codice  stato inviato alla vostra casella email. Inseritelo",
@@ -182,6 +191,7 @@
 "firstName":"Nome",
 "forbidden":"Accesso VIETATO",
 "forgotPwd":"Password dimenticata?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Generare automaticamente la password",
 "generic":"Informazioni di contatto",
 "generic2fFormatError":"Le informazioni di contatto non corrispondono al formato richiesto",
@@ -266,6 +276,15 @@
 "openidPA":"La politica di utilizzo dei dati  disponibile all'indirizzo",
 "openidRpns":"Il parametro %s richiesto per la federazione non  disponibile",
 "otherSessions":"Altre sessioni attive",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Password",
 "password2f":"Password",
 "passwordCompromised":"Non trovato in un database di password compromesse",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Rimuovere altre sessioni",
 "rename":"Rename",
 "renewSession":"Rinnova la sessione",
+"requestedScope":"Requested scope",
 "resendCode":"Reinvio del codice",
 "resendConfirmMail":"Inviare nuovamente mail di conferma?",
 "resendTooSoon":"Attendere ancora un po' prima di provare a inviare nuovamente il codice",
@@ -354,6 +374,8 @@
 "upgradeSession":"Sessione di aggiornamento",
 "useYubikey":"Usa la tua Yubikey",
 "user":"Utente",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Data di validazione",
 "value":"Valore",
 "verify":"Verifica",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/mfe.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/mfe.json
@@ -124,6 +124,7 @@
 "authLevel":"Nivo otantifikasion",
 "authPortal":"Portay otantifikasion",
 "authRemaining":"%s otantifikasion ki reste, sanz ou modpas!",
+"authorize":"Authorize",
 "autoAccept":"Aksepte otomatikman dan 30 segonn",
 "autoGlobalLogout":"Logout globalman otomatikman dan 30 segonn",
 "back2CasUrl":"Aplikasion kot ou fek dekonekte finn donn enn lien pou ou swiv",
@@ -149,6 +150,7 @@
 "click2Reset":"Klik isi pou reset ou modpas",
 "clickHere":"Klik isi silvouple",
 "clickOnYubikey":"Klik lor ou Yubikey",
+"clientId":"Client ID",
 "close":"Ferme",
 "closeSSO":"Ferm ou sesion SSO",
 "code":"Kod",
@@ -166,6 +168,13 @@
 "currentPwd":"Modpas aktiel",
 "date":"Dat",
 "decryptCipheredValue":"Desifre enn valer kode",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Silvouple rant ou bann idantifian",
 "enterExt2fCode":"Finn avoy ou enn kod. Met li silvouple",
 "enterMail2fCode":"Finn avoy enn kod lor ou ladres email. Met li silvouple",
@@ -182,6 +191,7 @@
 "firstName":"Prenom",
 "forbidden":"Akse INTERDI",
 "forgotPwd":"Finn bliye ou modpas?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Zener modpas-la otomatikman",
 "generic":"Bann linformasion kontak",
 "generic2fFormatError":"Ou bann linformasion kontak pa koresponn avek format neseser",
@@ -266,6 +276,15 @@
 "openidPA":"Polisi itilizasion done disponib lor",
 "openidRpns":"Paramet %s ki finn demande pou federasion pa disponib",
 "otherSessions":"Bann lezot sesion aktif",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Modpas",
 "password2f":"Modpas",
 "passwordCompromised":"Pa finn trouve dan enn baz done bann modpas ki finn konpromi",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Retir bann lezot sesion",
 "rename":"Rename",
 "renewSession":"Renouvle sesion",
+"requestedScope":"Requested scope",
 "resendCode":"Re-avoy kod",
 "resendConfirmMail":"Re-avoy bann mail konfirmasion?",
 "resendTooSoon":"Silvouple atann inpe plis avan sey re-avoy kod-la",
@@ -354,6 +374,8 @@
 "upgradeSession":"Sesion ameliorasion",
 "useYubikey":"servi ou Yubikey",
 "user":"Itilizater",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Dat validasion",
 "value":"Valer",
 "verify":"Verifie",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/pl.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/pl.json
@@ -124,6 +124,7 @@
 "authLevel":"Poziom uwierzytelnienia",
 "authPortal":"Portal uwierzytelniania",
 "authRemaining":"Pozostao %s uwierzytelnie, zmie haso!",
+"authorize":"Authorize",
 "autoAccept":"Automatycznie zaakceptuj w cigu 30 sekund",
 "autoGlobalLogout":"Automatyczne globalne wylogowanie w cigu 30 sekund",
 "back2CasUrl":"Aplikacja, z ktrej wanie si wylogowae, udostpniaa link, ktry chciae ledzi",
@@ -149,6 +150,7 @@
 "click2Reset":"Kliknij tu, by zresetowa swoje haso",
 "clickHere":"Kliknij tutaj",
 "clickOnYubikey":"Aktywuj swj Yubikey",
+"clientId":"Client ID",
 "close":"Zamknij",
 "closeSSO":"Zamknij sesj logowania jednokrotnego",
 "code":"Kod",
@@ -166,6 +168,13 @@
 "currentPwd":"Aktualne haso",
 "date":"Data",
 "decryptCipheredValue":"Odszyfruj zaszyfrowan warto",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Prosz poda swoje dane uwierzytelniajce",
 "enterExt2fCode":"Kod zosta wysany do ciebie. Prosz go teraz wpisa",
 "enterMail2fCode":"Kod zosta wysany na twj adres e-mail. Prosz go teraz wpisa",
@@ -182,6 +191,7 @@
 "firstName":"Imi",
 "forbidden":"Dostp ZABRONIONY",
 "forgotPwd":"Zapomniae hasa?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Wygeneruj haso automatycznie",
 "generic":"Informacje kontaktowe",
 "generic2fFormatError":"Twoje dane kontaktowe nie pasuj do wymaganego formatu",
@@ -266,6 +276,15 @@
 "openidPA":"Polityka przetwarzania danych jest dostpna pod adresem",
 "openidRpns":"Parametr %s wymagany dla federacji jest niedostpny",
 "otherSessions":"Inne aktywne sesje",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Haso",
 "password2f":"Haso",
 "passwordCompromised":"Nie znaleziono w przejtej bazie danych hase",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Usu inne sesje",
 "rename":"Rename",
 "renewSession":"Odnw sesj",
+"requestedScope":"Requested scope",
 "resendCode":"Ponownie wylij kod",
 "resendConfirmMail":"Czy wysa ponownie wiadomo z potwierdzeniem?",
 "resendTooSoon":"Poczekaj troch duej, zanim sprbujesz ponownie wysa kod",
@@ -354,6 +374,8 @@
 "upgradeSession":"Aktualizacja sesji",
 "useYubikey":"uyj swojego Yubikey",
 "user":"Uytkownik",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Data walidacji",
 "value":"Warto",
 "verify":"Zweryfikuj",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/pt.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/pt.json
@@ -124,6 +124,7 @@
 "authLevel":"Nvel de autenticao",
 "authPortal":"Portal de autenticao",
 "authRemaining":"%sautenticaes restantes, altere sua senha!",
+"authorize":"Authorize",
 "autoAccept":"Aceitar automaticamente em 30 segundos",
 "autoGlobalLogout":"Logout global automtico em 30 segundos",
 "back2CasUrl":"O aplicativo do qual voc acabou de sair forneceu um link que gostaria que voc seguisse",
@@ -149,6 +150,7 @@
 "click2Reset":"Clique aqui para renovar a sua senha",
 "clickHere":"Por favor, clique aqui",
 "clickOnYubikey":"Clique no seu Yubikey",
+"clientId":"Client ID",
 "close":"Fechar",
 "closeSSO":"Feche sua sesso SSO",
 "code":"Cdigo",
@@ -166,6 +168,13 @@
 "currentPwd":"Senha atual",
 "date":"Data",
 "decryptCipheredValue":"Descriptografar um valor cifrado",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Por favor insira suas credenciais",
 "enterExt2fCode":"Um cdigo foi enviado para voc. Por favor o insira",
 "enterMail2fCode":"Um cdigo foi enviado para o seu endereo de e-mail. Por favor o insira",
@@ -182,6 +191,7 @@
 "firstName":"Primeiro nome",
 "forbidden":"Acesso PROIBIDO",
 "forgotPwd":"Esqueceu sua senha?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Gere a senha automaticamente",
 "generic":"Informaes de contato",
 "generic2fFormatError":"Suas informaes de contato no atendem ao formato exigido",
@@ -266,6 +276,15 @@
 "openidPA":"A poltica de uso de dados est disponvel em",
 "openidRpns":"Parmetro %s solicitado para federao no est disponvel",
 "otherSessions":"Outras sesses ativas",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Senha",
 "password2f":"Senha",
 "passwordCompromised":"No foi encontrada em um banco de dados de senhas comprometidas",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Remover outras sesses",
 "rename":"Rename",
 "renewSession":"Renovar sesso",
+"requestedScope":"Requested scope",
 "resendCode":"Reenviar cdigo",
 "resendConfirmMail":"Reenviar e-mail de confirmao?",
 "resendTooSoon":"Por favor aguarde um pouco mais antes de tentar reenviar o cdigo",
@@ -354,6 +374,8 @@
 "upgradeSession":"Upgrade da sesso",
 "useYubikey":"use seu Yubikey",
 "user":"Usurio",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Data de validao",
 "value":"Valor",
 "verify":"Verificar",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/pt_BR.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/pt_BR.json
@@ -124,6 +124,7 @@
 "authLevel":"Nvel de autenticao",
 "authPortal":"Portal de autenticao",
 "authRemaining":"%sautenticaes restantes, altere sua senha!",
+"authorize":"Authorize",
 "autoAccept":"Aceitar automaticamente em 30 segundos",
 "autoGlobalLogout":"Logout global automtico em 30 segundos",
 "back2CasUrl":"O aplicativo do qual voc acabou de sair forneceu um link que gostaria que voc seguisse",
@@ -149,6 +150,7 @@
 "click2Reset":"Clique aqui para renovar a sua senha",
 "clickHere":"Por favor, clique aqui",
 "clickOnYubikey":"Clique no seu Yubikey",
+"clientId":"Client ID",
 "close":"Fechar",
 "closeSSO":"Feche sua sesso SSO",
 "code":"Cdigo",
@@ -166,6 +168,13 @@
 "currentPwd":"Senha atual",
 "date":"Data",
 "decryptCipheredValue":"Descriptografar um valor cifrado",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Por favor insira suas credenciais",
 "enterExt2fCode":"Um cdigo foi enviado para voc. Por favor o insira",
 "enterMail2fCode":"Um cdigo foi enviado para o seu endereo de e-mail. Por favor o insira",
@@ -182,6 +191,7 @@
 "firstName":"Primeiro nome",
 "forbidden":"Acesso PROIBIDO",
 "forgotPwd":"Esqueceu sua senha?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Gere a senha automaticamente",
 "generic":"Informaes de contato",
 "generic2fFormatError":"Suas informaes de contato no atendem ao formato exigido",
@@ -266,6 +276,15 @@
 "openidPA":"A poltica de uso de dados est disponvel em",
 "openidRpns":"Parmetro %s solicitado para federao no est disponvel",
 "otherSessions":"Outras sesses ativas",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Senha",
 "password2f":"Senha",
 "passwordCompromised":"No foi encontrada em um banco de dados de senhas comprometidas",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Remover outras sesses",
 "rename":"Rename",
 "renewSession":"Renovar sesso",
+"requestedScope":"Requested scope",
 "resendCode":"Reenviar cdigo",
 "resendConfirmMail":"Reenviar e-mail de confirmao?",
 "resendTooSoon":"Por favor aguarde um pouco mais antes de tentar reenviar o cdigo",
@@ -354,6 +374,8 @@
 "upgradeSession":"Upgrade da sesso",
 "useYubikey":"use seu Yubikey",
 "user":"Usurio",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Data de validao",
 "value":"Valor",
 "verify":"Verificar",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/ru.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/ru.json
@@ -124,6 +124,7 @@
 "authLevel":" ",
 "authPortal":" ",
 "authRemaining":" %s ,  !",
+"authorize":"Authorize",
 "autoAccept":"   30 ",
 "autoGlobalLogout":"    30 ",
 "back2CasUrl":",      ,  ,    ",
@@ -149,6 +150,7 @@
 "click2Reset":",   ",
 "clickHere":" ",
 "clickOnYubikey":"   Yubikey",
+"clientId":"Client ID",
 "close":"",
 "closeSSO":"   ",
 "code":"",
@@ -166,6 +168,13 @@
 "currentPwd":" ",
 "date":"",
 "decryptCipheredValue":"  ",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":",    ",
 "enterExt2fCode":"   . ,  ",
 "enterMail2fCode":"     . ,  ",
@@ -182,6 +191,7 @@
 "firstName":"",
 "forbidden":" ",
 "forgotPwd":" ?",
+"generatePamToken":"Generate Token",
 "generatePwd":"  ",
 "generic":" ",
 "generic2fFormatError":"Your contact information does not match the required format",
@@ -266,6 +276,15 @@
 "openidPA":"    ",
 "openidRpns":" %s,   federation, ",
 "otherSessions":"  ",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"",
 "password2f":"",
 "passwordCompromised":"     ",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"  ",
 "rename":"Rename",
 "renewSession":" ",
+"requestedScope":"Requested scope",
 "resendCode":"   ",
 "resendConfirmMail":"     ?",
 "resendTooSoon":",  ,      ",
@@ -354,6 +374,8 @@
 "upgradeSession":" ",
 "useYubikey":"  Yubikey",
 "user":"",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":" ",
 "value":"",
 "verify":"",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/sk.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/sk.json
@@ -124,6 +124,7 @@
 "authLevel":"rove autentifikcie",
 "authPortal":"Portl autentifikcie",
 "authRemaining":"%s autentifikci zostva, zmete svoje heslo!",
+"authorize":"Authorize",
 "autoAccept":"Automaticky prija za 30 seknd",
 "autoGlobalLogout":"Automatick globlna odhlsenie za 30 seknd",
 "back2CasUrl":"Aplikcia, z ktorej ste sa prve odhlsili, poskytla odkaz, ktor by ste mali sledova",
@@ -149,6 +150,7 @@
 "click2Reset":"Kliknite sem na resetovanie hesla",
 "clickHere":"Prosm, kliknite sem",
 "clickOnYubikey":"Kliknite na svoju Yubikey",
+"clientId":"Client ID",
 "close":"Zavrie",
 "closeSSO":"Zavrie svoju SSO relciu",
 "code":"Kd",
@@ -166,6 +168,13 @@
 "currentPwd":"Aktulne heslo",
 "date":"Dtum",
 "decryptCipheredValue":"Deifrova zaifrovan hodnotu",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Prosm, zadajte svoje poverenia",
 "enterExt2fCode":"Kd bol odoslan na vs. Prosm, zadajte ho",
 "enterMail2fCode":"Kd bol odoslan na vau e-mailov adresu. Prosm, zadajte ho",
@@ -182,6 +191,7 @@
 "firstName":"Meno",
 "forbidden":"Prstup ZAKZAN",
 "forgotPwd":"Zabudli ste svoje heslo?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Automaticky vygenerova heslo",
 "generic":"Kontaktn informcie",
 "generic2fFormatError":"Vae kontaktn informcie nevyhovuj poadovanmu formtu",
@@ -266,6 +276,15 @@
 "openidPA":"Politika pouvania dajov je k dispozcii na",
 "openidRpns":"Parametr %s poadovan na federciu nie je k dispozcii",
 "otherSessions":"In aktvne relcie",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Heslo",
 "password2f":"Heslo",
 "passwordCompromised":"Nenjden v databze kompromitovanch hesiel",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Odstrni in relcie",
 "rename":"Rename",
 "renewSession":"Obnovi relciu",
+"requestedScope":"Requested scope",
 "resendCode":"Znovu odosla kd",
 "resendConfirmMail":"Znovu odosla potvrdzovac e-mail?",
 "resendTooSoon":"Prosm, pokajte trochu dlhie pred pokusom o optovn odoslanie kdu",
@@ -354,6 +374,8 @@
 "upgradeSession":"Zvi relciu",
 "useYubikey":"pouite svoju Yubikey",
 "user":"Pouvate",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Dtum overenia",
 "value":"Hodnota",
 "verify":"Overi",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/tr.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/tr.json
@@ -124,6 +124,7 @@
 "authLevel":"Kimlik dorulama dzeyi",
 "authPortal":"Kimlik dorulama portal",
 "authRemaining":"%s kimlik dorulamas kald, parolanz deitirin!",
+"authorize":"Authorize",
 "autoAccept":"30 saniye ierisinde otomatik olarak kabul et",
 "autoGlobalLogout":"30 saniye iinde otomatik olarak global k yap",
 "back2CasUrl":"k yaptnz uygulama, takip etmenizi istedii bir balant salad",
@@ -149,6 +150,7 @@
 "click2Reset":"Parolanz sfrlamak iin buraya tklayn",
 "clickHere":"Ltfen buraya tklayn",
 "clickOnYubikey":"Yubikey'e tklayn",
+"clientId":"Client ID",
 "close":"Kapal",
 "closeSSO":"TOA oturumunuzu kapatn",
 "code":"Kod",
@@ -166,6 +168,13 @@
 "currentPwd":"Mevcut parola",
 "date":"Tarih",
 "decryptCipheredValue":"ifrelenmi deeri z",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Ltfen kimlik bilgilerinizi giriniz",
 "enterExt2fCode":"Size bir kod gnderildi. Ltfen onu giriniz",
 "enterMail2fCode":"E-posta adresinize bir kod gnderildi. Ltfen onu giriniz",
@@ -182,6 +191,7 @@
 "firstName":"Ad",
 "forbidden":"Eriim YASAKLI",
 "forgotPwd":"Parolanz m unuttunuz?",
+"generatePamToken":"Generate Token",
 "generatePwd":"Parolay otomatik olarak olutur",
 "generic":"letiim bilgileri",
 "generic2fFormatError":"letiim bilgileriniz gerekli formatla elemiyor",
@@ -266,6 +276,15 @@
 "openidPA":"Veri kullanm ilkesi mevcut",
 "openidRpns":"Federasyon iin %s parametre istei mevcut deil!",
 "otherSessions":"Dier aktif oturumlar",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Parola",
 "password2f":"Parola",
 "passwordCompromised":"Gvenlii ihlal edilmi bir parola veritabannda bulunamad",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Dier oturumlar sil",
 "rename":"Rename",
 "renewSession":"Oturumu yenile",
+"requestedScope":"Requested scope",
 "resendCode":"Kodu tekrar gnder",
 "resendConfirmMail":"Dorulama e-postasn tekrar gnder?",
 "resendTooSoon":"Ltfen kodu yeniden gndermeyi denemeden nce biraz bekleyin.",
@@ -354,6 +374,8 @@
 "upgradeSession":"Oturumu ykselt",
 "useYubikey":"Yubikey'inizi kullann",
 "user":"Kullanc",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"Dorulama tarihi",
 "value":"Deer",
 "verify":"Dorula",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/vi.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/vi.json
@@ -124,6 +124,7 @@
 "authLevel":"Mc xc thc",
 "authPortal":"Cng thng tin xc thc",
 "authRemaining":"%s xc thc vn cn, thay i mt khu ca bn!",
+"authorize":"Authorize",
 "autoAccept":"T ng chp nhn trong 30 giy",
 "autoGlobalLogout":"T ng ng xut tt c sau 30 giy",
 "back2CasUrl":"ng dng bn va ng xut  cung cp mt lin kt m bn mun theo di",
@@ -149,6 +150,7 @@
 "click2Reset":"Nhn  y  thit lp li mt khu ca bn",
 "clickHere":"Vui lng nhp vo y",
 "clickOnYubikey":"Nhp vo Yubikey ca bn",
+"clientId":"Client ID",
 "close":"ng",
 "closeSSO":"ng phin SSO ca bn",
 "code":"M",
@@ -166,6 +168,13 @@
 "currentPwd":"Mt khu hin ti",
 "date":"Ngy",
 "decryptCipheredValue":"Gii m mt gi tr c m ha",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"Vui lng nhp thng tin ng nhp ca bn",
 "enterExt2fCode":"Mt m  c gi cho bn. Hy nhp n",
 "enterMail2fCode":"Mt m  c gi n a ch email ca bn. Vui lng nhp m ",
@@ -182,6 +191,7 @@
 "firstName":"Tn",
 "forbidden":"Truy cp b cm",
 "forgotPwd":"Qun mt khu ca bn?",
+"generatePamToken":"Generate Token",
 "generatePwd":"To mt khu t ng",
 "generic":"Thng tin lin lc",
 "generic2fFormatError":"Your contact information does not match the required format",
@@ -266,6 +276,15 @@
 "openidPA":"Chnh sch s dng d liu c sn ti",
 "openidRpns":" yu cu tham s %s khng c sn",
 "otherSessions":"Cc phin hot ng khc",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"Mt khu",
 "password2f":"Mt khu",
 "passwordCompromised":"Khng tm thy trong mt c s d liu mt khu b xm nhp",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"Xa cc phin khc",
 "rename":"Rename",
 "renewSession":"lm mi phin",
+"requestedScope":"Requested scope",
 "resendCode":"Gi li m",
 "resendConfirmMail":"Gi li th xc nhn?",
 "resendTooSoon":"Vui lng i thm trc khi th gi li m",
@@ -354,6 +374,8 @@
 "upgradeSession":"Phin nng cp",
 "useYubikey":"s dng Yubikey ca bn",
 "user":"Ngi dng",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"ngy xc nhn",
 "value":"Gi tr",
 "verify":"Xc minh",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/zh.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/zh.json
@@ -124,6 +124,7 @@
 "authLevel":"",
 "authPortal":"",
 "authRemaining":" %s ",
+"authorize":"Authorize",
 "autoAccept":"30",
 "autoGlobalLogout":"30",
 "back2CasUrl":"",
@@ -149,6 +150,7 @@
 "click2Reset":"",
 "clickHere":"",
 "clickOnYubikey":" Yubikey",
+"clientId":"Client ID",
 "close":"Close",
 "closeSSO":" SSO ",
 "code":"",
@@ -166,6 +168,13 @@
 "currentPwd":"",
 "date":"",
 "decryptCipheredValue":"",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"",
 "enterExt2fCode":"",
 "enterMail2fCode":"",
@@ -182,6 +191,7 @@
 "firstName":"",
 "forbidden":"",
 "forgotPwd":"",
+"generatePamToken":"Generate Token",
 "generatePwd":"",
 "generic":"Contact information",
 "generic2fFormatError":"Your contact information does not match the required format",
@@ -266,6 +276,15 @@
 "openidPA":"",
 "openidRpns":" %s ",
 "otherSessions":"",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"",
 "password2f":"",
 "passwordCompromised":"Not found in a compromised password database",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"",
 "rename":"Rename",
 "renewSession":"",
+"requestedScope":"Requested scope",
 "resendCode":"Re-send code",
 "resendConfirmMail":"",
 "resendTooSoon":"Please wait a little longer before trying to re-send the code",
@@ -354,6 +374,8 @@
 "upgradeSession":"",
 "useYubikey":" Yubikey",
 "user":"",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"",
 "value":"",
 "verify":"",
--- a/usr/share/lemonldap-ng/portal/htdocs/static/languages/zh_TW.json
+++ b/usr/share/lemonldap-ng/portal/htdocs/static/languages/zh_TW.json
@@ -124,6 +124,7 @@
 "authLevel":"",
 "authPortal":"",
 "authRemaining":" %s ",
+"authorize":"Authorize",
 "autoAccept":"30",
 "autoGlobalLogout":"30",
 "back2CasUrl":"",
@@ -149,6 +150,7 @@
 "click2Reset":"",
 "clickHere":"",
 "clickOnYubikey":" Yubikey",
+"clientId":"Client ID",
 "close":"Close",
 "closeSSO":" SSO ",
 "code":"",
@@ -166,6 +168,13 @@
 "currentPwd":"",
 "date":"",
 "decryptCipheredValue":"",
+"deny":"Deny",
+"deviceApproved":"Device Approved",
+"deviceApprovedMsg":"The device has been authorized. You can close this window.",
+"deviceAuthorization":"Device Authorization",
+"deviceAuthorizationMsg":"Enter the code displayed on your device to authorize it.",
+"deviceDenied":"Device Denied",
+"deviceDeniedMsg":"The device authorization has been denied. You can close this window.",
 "enterCred":"",
 "enterExt2fCode":"",
 "enterMail2fCode":"",
@@ -182,6 +191,7 @@
 "firstName":"",
 "forbidden":"",
 "forgotPwd":"",
+"generatePamToken":"Generate Token",
 "generatePwd":"",
 "generic":"Contact information",
 "generic2fFormatError":"Your contact information does not match the required format",
@@ -266,6 +276,15 @@
 "openidPA":"",
 "openidRpns":" %s ",
 "otherSessions":"",
+"pamAccessInfo":"Generate a temporary token to use as your password for SSH or other PAM-enabled services.",
+"pamAccessTitle":"PAM Access Token",
+"pamExpiresIn":"Expires in",
+"pamInstructions":"Instructions",
+"pamInstructionsText":"Use this token as your password when connecting via SSH or other PAM-enabled services.",
+"pamLogin":"Login",
+"pamTokenDuration":"Token validity",
+"pamTokenError":"Failed to generate token",
+"pamTokenGenerated":"Your temporary token",
 "password":"",
 "password2f":"",
 "passwordCompromised":"Not found in a compromised password database",
@@ -304,6 +323,7 @@
 "removeOtherSessions":"",
 "rename":"Rename",
 "renewSession":"",
+"requestedScope":"Requested scope",
 "resendCode":"Re-send code",
 "resendConfirmMail":"",
 "resendTooSoon":"Please wait a little longer before trying to re-send the code",
@@ -354,6 +374,8 @@
 "upgradeSession":"",
 "useYubikey":" Yubikey",
 "user":"",
+"userCode":"Device Code",
+"userCodeHelp":"Enter the 8-character code shown on your device",
 "validationDate":"",
 "value":"",
 "verify":"",
new file mode 100644
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/js-src/pamaccess.js
@@ -0,0 +1,60 @@
+(function() {
+  $(window).on("load", function() {
+    var form = document.getElementById('pamTokenForm');
+    if (!form) return;
+
+    var resultDiv = document.getElementById('pamTokenResult');
+    var errorDiv = document.getElementById('pamTokenError');
+    var tokenInput = document.getElementById('pamToken');
+    var loginSpan = document.getElementById('pamLogin');
+    var expiresSpan = document.getElementById('pamExpiresIn');
+    var copyBtn = document.getElementById('copyPamToken');
+    var errorMsg = document.getElementById('pamErrorMessage');
+
+    form.addEventListener('submit', function(e) {
+      e.preventDefault();
+      resultDiv.classList.add('d-none');
+      errorDiv.classList.add('d-none');
+
+      var duration = document.getElementById('pamDuration').value;
+
+      $.ajax({
+        type: "POST",
+        url: scriptname + 'pam',
+        data: { duration: duration },
+        dataType: "json",
+        success: function(data) {
+          if (data.error) {
+            errorMsg.textContent = data.error;
+            errorDiv.classList.remove('d-none');
+          } else {
+            tokenInput.value = data.token;
+            loginSpan.textContent = data.login;
+            var minutes = Math.floor(data.expires_in / 60);
+            var seconds = data.expires_in % 60;
+            expiresSpan.textContent = minutes + ' min ' + (seconds > 0 ? seconds + ' sec' : '');
+            resultDiv.classList.remove('d-none');
+          }
+        },
+        error: function(xhr, status, error) {
+          errorMsg.textContent = error || status;
+          errorDiv.classList.remove('d-none');
+        }
+      });
+    });
+
+    // Copy button
+    if (copyBtn) {
+      copyBtn.addEventListener('click', function() {
+        tokenInput.select();
+        tokenInput.setSelectionRange(0, 99999);
+        navigator.clipboard.writeText(tokenInput.value).then(function() {
+          copyBtn.innerHTML = '<span class="fa fa-check"></span>';
+          setTimeout(function() {
+            copyBtn.innerHTML = '<span class="fa fa-copy"></span>';
+          }, 2000);
+        });
+      });
+    }
+  });
+})();
new file mode 100644
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/js-src/sshca.js
@@ -0,0 +1,100 @@
+(function() {
+  $(window).on("load", function() {
+    var form = document.getElementById('sshCaForm');
+    if (!form) return;
+
+    var resultDiv = document.getElementById('sshCaResult');
+    var errorDiv = document.getElementById('sshCaError');
+    var certTextarea = document.getElementById('sshCertificate');
+    var keyIdSpan = document.getElementById('sshKeyId');
+    var principalsSpan = document.getElementById('sshPrincipals');
+    var validUntilSpan = document.getElementById('sshValidUntil');
+    var copyBtn = document.getElementById('copySshCert');
+    var errorMsg = document.getElementById('sshCaErrorMessage');
+    var validitySelect = document.getElementById('sshValidity');
+
+    // Filter validity options based on max validity
+    if (validitySelect) {
+      var maxValidity = parseInt(validitySelect.dataset.maxValidity) || 365;
+      var options = validitySelect.querySelectorAll('option');
+      var lastValidOption = null;
+
+      options.forEach(function(option) {
+        var value = parseInt(option.value);
+        if (value > maxValidity) {
+          option.remove();
+        } else {
+          lastValidOption = option;
+        }
+      });
+
+      // Select the highest valid option if the default was removed
+      var selectedOption = validitySelect.querySelector('option[selected]');
+      if (!selectedOption && lastValidOption) {
+        lastValidOption.selected = true;
+      }
+    }
+
+    form.addEventListener('submit', function(e) {
+      e.preventDefault();
+      resultDiv.classList.add('d-none');
+      errorDiv.classList.add('d-none');
+
+      var publicKey = document.getElementById('sshPublicKey').value.trim();
+      var validityDays = parseInt(validitySelect.value);
+
+      if (!publicKey) {
+        errorMsg.textContent = 'Please paste your SSH public key';
+        errorDiv.classList.remove('d-none');
+        return;
+      }
+
+      $.ajax({
+        type: "POST",
+        url: scriptname + 'ssh/sign',
+        contentType: "application/json",
+        data: JSON.stringify({
+          public_key: publicKey,
+          validity_days: validityDays
+        }),
+        dataType: "json",
+        success: function(data) {
+          if (data.error) {
+            errorMsg.textContent = data.error;
+            errorDiv.classList.remove('d-none');
+          } else {
+            certTextarea.value = data.certificate;
+            keyIdSpan.textContent = data.key_id;
+            principalsSpan.textContent = data.principals.join(', ');
+            validUntilSpan.textContent = data.valid_until;
+            resultDiv.classList.remove('d-none');
+          }
+        },
+        error: function(xhr, status, error) {
+          var msg = error || status;
+          try {
+            var resp = JSON.parse(xhr.responseText);
+            if (resp.error) msg = resp.error;
+          } catch(e) {}
+          errorMsg.textContent = msg;
+          errorDiv.classList.remove('d-none');
+        }
+      });
+    });
+
+    // Copy button
+    if (copyBtn) {
+      copyBtn.addEventListener('click', function() {
+        certTextarea.select();
+        certTextarea.setSelectionRange(0, 99999);
+        navigator.clipboard.writeText(certTextarea.value).then(function() {
+          var originalHtml = copyBtn.innerHTML;
+          copyBtn.innerHTML = '<span class="fa fa-check"></span> Copied!';
+          setTimeout(function() {
+            copyBtn.innerHTML = originalHtml;
+          }, 2000);
+        });
+      });
+    }
+  });
+})();
new file mode 100644
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/js-src/sshcaadmin.js
@@ -0,0 +1,317 @@
+(function() {
+  'use strict';
+
+  var currentPage = 0;
+  var pageSize = 20;
+  var totalCerts = 0;
+  var revokeModal = null;
+  var alertToast = null;
+
+  // Escape HTML to prevent XSS
+  function escapeHtml(str) {
+    if (str === null || str === undefined) return '';
+    return String(str)
+      .replace(/&/g, '&amp;')
+      .replace(/</g, '&lt;')
+      .replace(/>/g, '&gt;')
+      .replace(/"/g, '&quot;')
+      .replace(/'/g, '&#039;');
+  }
+
+  // Get the base URL (script name without trailing slash)
+  function getBaseUrl() {
+    var path = window.location.pathname;
+    // Remove /ssh/admin from the path to get the base
+    return path.replace(/\/ssh\/admin\/?$/, '');
+  }
+
+  // Format timestamp to readable date
+  function formatDate(timestamp) {
+    if (!timestamp) return '-';
+    var d = new Date(timestamp * 1000);
+    return d.toLocaleString();
+  }
+
+  // Get status badge HTML
+  function getStatusBadge(status) {
+    var badgeClass = 'bg-secondary';
+    var text = status;
+
+    switch(status) {
+      case 'active':
+        badgeClass = 'bg-success';
+        break;
+      case 'expired':
+        badgeClass = 'bg-secondary';
+        break;
+      case 'revoked':
+        badgeClass = 'bg-danger';
+        break;
+    }
+
+    return '<span class="badge ' + badgeClass + '">' + text + '</span>';
+  }
+
+  // Show toast notification
+  function showToast(message, type) {
+    var toastEl = document.getElementById('alertToast');
+    var toastIcon = document.getElementById('toastIcon');
+    var toastTitle = document.getElementById('toastTitle');
+    var toastMessage = document.getElementById('toastMessage');
+
+    toastMessage.textContent = message;
+
+    if (type === 'success') {
+      toastIcon.className = 'fa fa-check-circle me-2 text-success';
+      toastTitle.textContent = 'Success';
+    } else if (type === 'error') {
+      toastIcon.className = 'fa fa-exclamation-circle me-2 text-danger';
+      toastTitle.textContent = 'Error';
+    } else {
+      toastIcon.className = 'fa fa-info-circle me-2 text-info';
+      toastTitle.textContent = 'Info';
+    }
+
+    if (!alertToast) {
+      alertToast = new bootstrap.Toast(toastEl);
+    }
+    alertToast.show();
+  }
+
+  // Load certificates from API
+  function loadCertificates(page) {
+    currentPage = page || 0;
+    var offset = currentPage * pageSize;
+
+    var params = new URLSearchParams();
+    params.set('limit', pageSize);
+    params.set('offset', offset);
+
+    var user = document.getElementById('searchUser').value.trim();
+    var serial = document.getElementById('searchSerial').value.trim();
+    var keyId = document.getElementById('searchKeyId').value.trim();
+    var status = document.getElementById('searchStatus').value;
+
+    if (user) params.set('user', user);
+    if (serial) params.set('serial', serial);
+    if (keyId) params.set('key_id', keyId);
+    if (status) params.set('status', status);
+
+    var tableBody = document.getElementById('certsTable');
+    var loadingRow = document.getElementById('loadingRow');
+    var noResultsRow = document.getElementById('noResultsRow');
+    var searchPromptRow = document.getElementById('searchPromptRow');
+
+    // Show loading
+    loadingRow.classList.remove('d-none');
+    noResultsRow.classList.add('d-none');
+    if (searchPromptRow) searchPromptRow.classList.add('d-none');
+
+    // Remove existing cert rows
+    var existingRows = tableBody.querySelectorAll('.cert-row');
+    existingRows.forEach(function(row) { row.remove(); });
+
+    var baseUrl = getBaseUrl();
+
+    $.ajax({
+      type: 'GET',
+      url: baseUrl + '/ssh/certs?' + params.toString(),
+      dataType: 'json',
+      success: function(data) {
+        loadingRow.classList.add('d-none');
+
+        totalCerts = data.total || 0;
+        document.getElementById('resultCount').textContent = totalCerts;
+
+        if (!data.certificates || data.certificates.length === 0) {
+          noResultsRow.classList.remove('d-none');
+          updatePagination();
+          return;
+        }
+
+        noResultsRow.classList.add('d-none');
+
+        data.certificates.forEach(function(cert) {
+          var row = document.createElement('tr');
+          row.className = 'cert-row';
+          row.innerHTML =
+            '<td>' + escapeHtml(cert.serial || '-') + '</td>' +
+            '<td>' + escapeHtml(cert.user || '-') + '</td>' +
+            '<td><code>' + escapeHtml(cert.principals || '-') + '</code></td>' +
+            '<td>' + escapeHtml(formatDate(cert.issued_at)) + '</td>' +
+            '<td>' + escapeHtml(formatDate(cert.expires_at)) + '</td>' +
+            '<td>' + getStatusBadge(cert.status) + '</td>' +
+            '<td>' + getActionButtons(cert) + '</td>';
+          tableBody.appendChild(row);
+        });
+
+        // Bind revoke buttons
+        tableBody.querySelectorAll('.btn-revoke').forEach(function(btn) {
+          btn.addEventListener('click', function(e) {
+            e.preventDefault();
+            showRevokeModal(
+              this.dataset.sessionId,
+              this.dataset.serial,
+              this.dataset.user,
+              this.dataset.keyId
+            );
+          });
+        });
+
+        updatePagination();
+      },
+      error: function(xhr, status, error) {
+        loadingRow.classList.add('d-none');
+        noResultsRow.classList.remove('d-none');
+        noResultsRow.querySelector('td').textContent = 'Error loading certificates: ' + (error || status);
+        showToast('Failed to load certificates', 'error');
+      }
+    });
+  }
+
+  // Get action buttons HTML for a certificate
+  function getActionButtons(cert) {
+    if (cert.status === 'revoked') {
+      return '<span class="text-muted" title="Revoked by ' + escapeHtml(cert.revoked_by || 'unknown') +
+             ' at ' + escapeHtml(formatDate(cert.revoked_at)) + '">' +
+             '<span class="fa fa-ban"></span> Revoked</span>';
+    }
+
+    return '<button class="btn btn-sm btn-outline-danger btn-revoke" ' +
+           'data-session-id="' + escapeHtml(cert.session_id) + '" ' +
+           'data-serial="' + escapeHtml(cert.serial || '') + '" ' +
+           'data-user="' + escapeHtml(cert.user || '') + '" ' +
+           'data-key-id="' + escapeHtml(cert.key_id || '') + '">' +
+           '<span class="fa fa-ban"></span> Revoke</button>';
+  }
+
+  // Update pagination
+  function updatePagination() {
+    var pagination = document.getElementById('pagination');
+    pagination.innerHTML = '';
+
+    var totalPages = Math.ceil(totalCerts / pageSize);
+    if (totalPages <= 1) return;
+
+    // Previous button
+    var prevLi = document.createElement('li');
+    prevLi.className = 'page-item' + (currentPage === 0 ? ' disabled' : '');
+    prevLi.innerHTML = '<a class="page-link" href="#" data-page="' + (currentPage - 1) + '">&laquo;</a>';
+    pagination.appendChild(prevLi);
+
+    // Page numbers
+    var startPage = Math.max(0, currentPage - 2);
+    var endPage = Math.min(totalPages - 1, currentPage + 2);
+
+    for (var i = startPage; i <= endPage; i++) {
+      var li = document.createElement('li');
+      li.className = 'page-item' + (i === currentPage ? ' active' : '');
+      li.innerHTML = '<a class="page-link" href="#" data-page="' + i + '">' + (i + 1) + '</a>';
+      pagination.appendChild(li);
+    }
+
+    // Next button
+    var nextLi = document.createElement('li');
+    nextLi.className = 'page-item' + (currentPage >= totalPages - 1 ? ' disabled' : '');
+    nextLi.innerHTML = '<a class="page-link" href="#" data-page="' + (currentPage + 1) + '">&raquo;</a>';
+    pagination.appendChild(nextLi);
+
+    // Bind click handlers
+    pagination.querySelectorAll('.page-link').forEach(function(link) {
+      link.addEventListener('click', function(e) {
+        e.preventDefault();
+        var page = parseInt(this.dataset.page);
+        if (!isNaN(page) && page >= 0 && page < totalPages) {
+          loadCertificates(page);
+        }
+      });
+    });
+  }
+
+  // Show revoke modal
+  function showRevokeModal(sessionId, serial, user, keyId) {
+    document.getElementById('revokeSessionId').value = sessionId;
+    document.getElementById('revokeSerialInput').value = serial;
+    document.getElementById('revokeSerial').textContent = serial;
+    document.getElementById('revokeUser').textContent = user;
+    document.getElementById('revokeKeyId').textContent = keyId;
+    document.getElementById('revokeReason').value = '';
+
+    if (!revokeModal) {
+      revokeModal = new bootstrap.Modal(document.getElementById('revokeModal'));
+    }
+    revokeModal.show();
+  }
+
+  // Perform revocation
+  function revokeCertificate() {
+    var sessionId = document.getElementById('revokeSessionId').value;
+    var serial = document.getElementById('revokeSerialInput').value;
+    var reason = document.getElementById('revokeReason').value.trim();
+    var baseUrl = getBaseUrl();
+
+    $.ajax({
+      type: 'POST',
+      url: baseUrl + '/ssh/revoke',
+      contentType: 'application/json',
+      data: JSON.stringify({
+        session_id: sessionId,
+        serial: serial,
+        reason: reason
+      }),
+      dataType: 'json',
+      success: function(data) {
+        revokeModal.hide();
+        if (data.result) {
+          showToast('Certificate revoked successfully', 'success');
+          loadCertificates(currentPage);
+        } else {
+          showToast(data.error || 'Failed to revoke certificate', 'error');
+        }
+      },
+      error: function(xhr, status, error) {
+        revokeModal.hide();
+        var msg = error || status;
+        try {
+          var resp = JSON.parse(xhr.responseText);
+          if (resp.error) msg = resp.error;
+        } catch(e) {}
+        showToast('Failed to revoke certificate: ' + msg, 'error');
+      }
+    });
+  }
+
+  // Initialize on page load
+  $(window).on('load', function() {
+    // Search form submit
+    document.getElementById('searchForm').addEventListener('submit', function(e) {
+      e.preventDefault();
+      loadCertificates(0);
+    });
+
+    // Reset search - clear form and show search prompt
+    document.getElementById('resetSearch').addEventListener('click', function() {
+      document.getElementById('searchUser').value = '';
+      document.getElementById('searchSerial').value = '';
+      document.getElementById('searchKeyId').value = '';
+      document.getElementById('searchStatus').value = '';
+      // Clear results
+      var tableBody = document.getElementById('certsTable');
+      var existingRows = tableBody.querySelectorAll('.cert-row');
+      existingRows.forEach(function(row) { row.remove(); });
+      document.getElementById('loadingRow').classList.add('d-none');
+      document.getElementById('noResultsRow').classList.add('d-none');
+      var searchPromptRow = document.getElementById('searchPromptRow');
+      if (searchPromptRow) searchPromptRow.classList.remove('d-none');
+      document.getElementById('resultCount').textContent = '0';
+      document.getElementById('pagination').innerHTML = '';
+      totalCerts = 0;
+    });
+
+    // Confirm revoke button
+    document.getElementById('confirmRevoke').addEventListener('click', revokeCertificate);
+
+    // No initial load - wait for user to search
+    document.getElementById('loadingRow').classList.add('d-none');
+  });
+})();
new file mode 100644
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/templates/bootstrap/device.tpl
@@ -0,0 +1,113 @@
+<TMPL_INCLUDE NAME="header.tpl">
+
+<div id="logincontent" class="container">
+
+  <TMPL_IF NAME="DEVICE_APPROVED">
+    <!-- Device authorization approved -->
+    <div class="card border-success">
+      <div class="card-header text-white bg-success">
+        <h3 class="card-title">
+          <span class="fa fa-check-circle"></span>
+          <span trspan="deviceApproved">Device Approved</span>
+        </h3>
+      </div>
+      <div class="card-body">
+        <p trspan="deviceApprovedMsg">The device has been authorized. You can close this window.</p>
+        <TMPL_IF NAME="CLIENT_ID">
+          <p>
+            <strong trspan="clientId">Client ID</strong>: <TMPL_VAR NAME="CLIENT_ID">
+          </p>
+        </TMPL_IF>
+        <TMPL_IF NAME="SCOPE">
+          <p>
+            <strong trspan="requestedScope">Requested scope</strong>: <TMPL_VAR NAME="SCOPE">
+          </p>
+        </TMPL_IF>
+      </div>
+    </div>
+
+  <TMPL_ELSE>
+    <TMPL_IF NAME="DEVICE_DENIED">
+      <!-- Device authorization denied -->
+      <div class="card border-danger">
+        <div class="card-header text-white bg-danger">
+          <h3 class="card-title">
+            <span class="fa fa-times-circle"></span>
+            <span trspan="deviceDenied">Device Denied</span>
+          </h3>
+        </div>
+        <div class="card-body">
+          <p trspan="deviceDeniedMsg">The device authorization has been denied. You can close this window.</p>
+        </div>
+      </div>
+
+    <TMPL_ELSE>
+      <!-- Device code entry form -->
+      <form id="deviceform" action="<TMPL_VAR NAME="PORTAL_URL">device" method="post" class="login" role="form">
+
+        <input type="hidden" name="skin" value="<TMPL_VAR NAME="SKIN">" />
+
+        <div class="card border-info">
+          <div class="card-header text-white bg-info">
+            <h3 class="card-title">
+              <span class="fa fa-desktop"></span>
+              <span trspan="deviceAuthorization">Device Authorization</span>
+            </h3>
+          </div>
+          <div class="card-body">
+
+            <p trspan="deviceAuthorizationMsg">Enter the code displayed on your device to authorize it.</p>
+
+            <TMPL_IF NAME="ERROR">
+              <div class="alert alert-danger">
+                <span class="fa fa-exclamation-triangle"></span>
+                <span trspan="<TMPL_VAR NAME="MSG">"><TMPL_VAR NAME="MSG"></span>
+              </div>
+            </TMPL_IF>
+
+            <div class="form-group">
+              <label for="user_code" trspan="userCode">Device Code</label>
+              <input type="text"
+                     name="user_code"
+                     id="user_code"
+                     class="form-control form-control-lg text-center text-uppercase"
+                     value="<TMPL_VAR NAME="USER_CODE">"
+                     placeholder="XXXX-XXXX"
+                     pattern="[A-Za-z0-9\-]{6,12}"
+                     maxlength="12"
+                     autocomplete="off"
+                     autofocus
+                     required />
+              <small class="form-text text-muted" trspan="userCodeHelp">Enter the 8-character code shown on your device</small>
+            </div>
+
+            <div class="buttons">
+              <button type="submit" name="action" value="approve" class="btn btn-success btn-lg">
+                <span class="fa fa-check"></span>
+                <span trspan="authorize">Authorize</span>
+              </button>
+              <button type="submit" name="action" value="deny" class="btn btn-danger">
+                <span class="fa fa-times"></span>
+                <span trspan="deny">Deny</span>
+              </button>
+            </div>
+
+          </div>
+        </div>
+
+      </form>
+    </TMPL_IF>
+  </TMPL_IF>
+
+  <div id="back2portal">
+    <div class="buttons">
+      <a href="<TMPL_VAR NAME="PORTAL_URL">" class="btn btn-primary" role="button">
+        <span class="fa fa-home"></span>
+        <span trspan="goToPortal">Go to portal</span>
+      </a>
+    </div>
+  </div>
+
+</div>
+
+<TMPL_INCLUDE NAME="footer.tpl">
new file mode 100644
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/templates/bootstrap/pamaccess.tpl
@@ -0,0 +1,60 @@
+<script type="text/javascript" src="<TMPL_VAR NAME="js">"></script>
+<div class="card border-secondary">
+  <div class="card-header text-white bg-secondary">
+    <h4 class="card-title" trspan="pamAccessTitle">PAM Access Token</h4>
+  </div>
+  <div class="card-body">
+    <p trspan="pamAccessInfo">Generate a temporary token to use as your password for SSH or other PAM-enabled services.</p>
+
+    <form id="pamTokenForm" class="mb-4">
+      <div class="form-group row mb-3">
+        <label class="col-sm-4 col-form-label" for="pamDuration" trspan="pamTokenDuration">Token validity</label>
+        <div class="col-sm-8">
+          <select class="form-control" id="pamDuration" name="duration">
+            <option value="60">1 minute</option>
+            <option value="300">5 minutes</option>
+            <option value="600" selected>10 minutes</option>
+            <option value="1800">30 minutes</option>
+            <option value="3600">1 hour</option>
+          </select>
+        </div>
+      </div>
+      <div class="form-group row">
+        <div class="col-sm-8 offset-sm-4">
+          <button type="submit" class="btn btn-primary" id="generatePamToken">
+            <span class="fa fa-key"></span>
+            <span trspan="generatePamToken">Generate Token</span>
+          </button>
+        </div>
+      </div>
+    </form>
+
+    <div id="pamTokenResult" class="d-none">
+      <div class="alert alert-success">
+        <h5 trspan="pamTokenGenerated">Your temporary token</h5>
+        <div class="input-group mb-3">
+          <input type="text" class="form-control font-monospace" id="pamToken" readonly>
+          <button class="btn btn-outline-secondary" type="button" id="copyPamToken" title="Copy">
+            <span class="fa fa-copy"></span>
+          </button>
+        </div>
+        <p class="mb-1">
+          <strong trspan="pamLogin">Login:</strong>
+          <code id="pamLogin"></code>
+        </p>
+        <p class="mb-0">
+          <strong trspan="pamExpiresIn">Expires in:</strong>
+          <span id="pamExpiresIn"></span>
+        </p>
+      </div>
+      <div class="alert alert-info">
+        <h6 trspan="pamInstructions">Instructions</h6>
+        <p class="mb-0" trspan="pamInstructionsText">Use this token as your password when connecting via SSH or other PAM-enabled services.</p>
+      </div>
+    </div>
+
+    <div id="pamTokenError" class="alert alert-danger d-none">
+      <span trspan="pamTokenError">Failed to generate token</span>: <span id="pamErrorMessage"></span>
+    </div>
+  </div>
+</div>
new file mode 100644
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/templates/bootstrap/sshca.tpl
@@ -0,0 +1,82 @@
+<script type="text/javascript" src="<TMPL_VAR NAME="js">"></script>
+<div class="card border-secondary">
+  <div class="card-header text-white bg-secondary">
+    <h4 class="card-title" trspan="sshCaTitle">SSH Certificate</h4>
+  </div>
+  <div class="card-body">
+    <p trspan="sshCaInfo">Sign your SSH public key to obtain a short-lived certificate for passwordless authentication.</p>
+
+    <form id="sshCaForm" class="mb-4">
+      <div class="form-group mb-3">
+        <label for="sshPublicKey" trspan="sshPublicKey">SSH Public Key</label>
+        <textarea class="form-control font-monospace" id="sshPublicKey" name="public_key" rows="4"
+                  placeholder="ssh-ed25519 AAAA... user@host" required></textarea>
+        <small class="form-text text-muted" trspan="sshPublicKeyHelp">Paste the contents of your ~/.ssh/id_ed25519.pub or ~/.ssh/id_rsa.pub file</small>
+      </div>
+      <div class="form-group row mb-3">
+        <label class="col-sm-4 col-form-label" for="sshValidity" trspan="sshCertValidity">Certificate validity</label>
+        <div class="col-sm-8">
+          <select class="form-control" id="sshValidity" name="validity_days" data-max-validity="<TMPL_VAR NAME="MAX_VALIDITY_DAYS">">
+            <option value="1" data-trspan="oneDay">1 day</option>
+            <option value="7" data-trspan="oneWeek">1 week</option>
+            <option value="30" data-trspan="oneMonth" selected>1 month</option>
+            <option value="90" data-trspan="threeMonths">3 months</option>
+            <option value="180" data-trspan="sixMonths">6 months</option>
+            <option value="365" data-trspan="oneYear">1 year</option>
+          </select>
+          <small class="form-text text-muted">
+            <span trspan="sshCaMaxValidity">Maximum allowed</span>: <span id="maxValidityDisplay"><TMPL_VAR NAME="MAX_VALIDITY_DAYS"></span> <span trspan="days">days</span>
+          </small>
+        </div>
+      </div>
+      <div class="form-group row">
+        <div class="col-sm-8 offset-sm-4">
+          <button type="submit" class="btn btn-primary" id="signSshKey">
+            <span class="fa fa-certificate"></span>
+            <span trspan="signSshKey">Sign Key</span>
+          </button>
+        </div>
+      </div>
+    </form>
+
+    <div id="sshCaResult" class="d-none">
+      <div class="alert alert-success">
+        <h5 trspan="sshCertGenerated">Your SSH Certificate</h5>
+        <div class="mb-3">
+          <textarea class="form-control font-monospace" id="sshCertificate" rows="3" readonly></textarea>
+          <button class="btn btn-outline-secondary btn-sm mt-2" type="button" id="copySshCert">
+            <span class="fa fa-copy"></span>
+            <span trspan="copyCertificate">Copy certificate</span>
+          </button>
+        </div>
+        <p class="mb-1">
+          <strong trspan="sshKeyId">Key ID:</strong>
+          <code id="sshKeyId"></code>
+        </p>
+        <p class="mb-1">
+          <strong trspan="sshPrincipals">Principals:</strong>
+          <code id="sshPrincipals"></code>
+        </p>
+        <p class="mb-0">
+          <strong trspan="sshValidUntil">Valid until:</strong>
+          <span id="sshValidUntil"></span>
+        </p>
+      </div>
+      <div class="alert alert-info">
+        <h6 trspan="sshCaInstructions">How to use this certificate</h6>
+        <ol class="mb-0">
+          <li trspan="sshCaStep1">Save the certificate to a file next to your private key:</li>
+          <pre class="bg-light p-2 mt-1 mb-2"><code>~/.ssh/id_ed25519-cert.pub</code></pre>
+          <li trspan="sshCaStep2">SSH will automatically use the certificate when connecting:</li>
+          <pre class="bg-light p-2 mt-1 mb-2"><code>ssh user@server</code></pre>
+          <li trspan="sshCaStep3">Or specify it explicitly:</li>
+          <pre class="bg-light p-2 mt-1 mb-0"><code>ssh -i ~/.ssh/id_ed25519 user@server</code></pre>
+        </ol>
+      </div>
+    </div>
+
+    <div id="sshCaError" class="alert alert-danger d-none">
+      <span trspan="sshCaSignError">Failed to sign key</span>: <span id="sshCaErrorMessage"></span>
+    </div>
+  </div>
+</div>
new file mode 100644
--- /dev/null
+++ b/usr/share/lemonldap-ng/portal/templates/bootstrap/sshcaadmin.tpl
@@ -0,0 +1,155 @@
+<TMPL_INCLUDE NAME="header.tpl">
+
+<div id="sshcaadmin" class="container">
+  <h3 class="mb-4">
+    <span class="fa fa-certificate"></span>
+    <span trspan="sshCaAdminTitle">SSH Certificate Administration</span>
+  </h3>
+
+  <!-- Search Form -->
+  <div class="card mb-4">
+    <div class="card-header">
+      <h5 class="card-title mb-0" trspan="sshCaSearchTitle">Search Certificates</h5>
+    </div>
+    <div class="card-body">
+      <form id="searchForm" class="row g-3">
+        <div class="col-md-3">
+          <label for="searchUser" class="form-label" trspan="user">User</label>
+          <input type="text" class="form-control" id="searchUser" name="user" trplaceholder="user">
+        </div>
+        <div class="col-md-3">
+          <label for="searchSerial" class="form-label" trspan="serial">Serial</label>
+          <input type="text" class="form-control" id="searchSerial" name="serial" placeholder="12345">
+        </div>
+        <div class="col-md-3">
+          <label for="searchKeyId" class="form-label" trspan="keyId">Key ID</label>
+          <input type="text" class="form-control" id="searchKeyId" name="key_id" placeholder="user@llng-...">
+        </div>
+        <div class="col-md-3">
+          <label for="searchStatus" class="form-label" trspan="status">Status</label>
+          <select class="form-select" id="searchStatus" name="status">
+            <option value="" trspan="allStatuses">All</option>
+            <option value="active" trspan="active">Active</option>
+            <option value="expired" trspan="expired">Expired</option>
+            <option value="revoked" trspan="revoked">Revoked</option>
+          </select>
+        </div>
+        <div class="col-12">
+          <button type="submit" class="btn btn-primary">
+            <span class="fa fa-search"></span>
+            <span trspan="search">Search</span>
+          </button>
+          <button type="button" class="btn btn-outline-secondary" id="resetSearch">
+            <span class="fa fa-times"></span>
+            <span trspan="reset">Reset</span>
+          </button>
+        </div>
+      </form>
+    </div>
+  </div>
+
+  <!-- Results -->
+  <div class="card">
+    <div class="card-header d-flex justify-content-between align-items-center">
+      <h5 class="card-title mb-0" trspan="certificates">Certificates</h5>
+      <span id="resultCount" class="badge bg-secondary">0</span>
+    </div>
+    <div class="card-body p-0">
+      <div class="table-responsive">
+        <table class="table table-striped mb-0">
+          <thead>
+            <tr>
+              <th trspan="serial">Serial</th>
+              <th trspan="user">User</th>
+              <th trspan="principals">Principals</th>
+              <th trspan="issuedAt">Issued</th>
+              <th trspan="expiresAt">Expires</th>
+              <th trspan="status">Status</th>
+              <th trspan="actions">Actions</th>
+            </tr>
+          </thead>
+          <tbody id="certsTable">
+            <tr id="loadingRow" class="d-none">
+              <td colspan="7" class="text-center">
+                <span class="spinner-border spinner-border-sm" role="status"></span>
+                <span trspan="loading">Loading...</span>
+              </td>
+            </tr>
+            <tr id="noResultsRow" class="d-none">
+              <td colspan="7" class="text-center text-muted" trspan="noResults">No certificates found</td>
+            </tr>
+            <tr id="searchPromptRow">
+              <td colspan="7" class="text-center text-muted" trspan="sshCaSearchPrompt">Enter search criteria and click Search</td>
+            </tr>
+          </tbody>
+        </table>
+      </div>
+    </div>
+    <div class="card-footer">
+      <nav>
+        <ul class="pagination justify-content-center mb-0" id="pagination">
+        </ul>
+      </nav>
+    </div>
+  </div>
+
+  <!-- Back link -->
+  <div class="buttons mt-4">
+    <a href="<TMPL_VAR NAME="PORTAL_URL">" class="btn btn-primary" role="button">
+      <span class="fa fa-home"></span>
+      <span trspan="goToPortal">Go to portal</span>
+    </a>
+  </div>
+</div>
+
+<!-- Revoke Modal -->
+<div class="modal fade" id="revokeModal" tabindex="-1" aria-labelledby="revokeModalLabel" aria-hidden="true">
+  <div class="modal-dialog">
+    <div class="modal-content">
+      <div class="modal-header">
+        <h5 class="modal-title" id="revokeModalLabel" trspan="revokeCertificate">Revoke Certificate</h5>
+        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
+      </div>
+      <div class="modal-body">
+        <p trspan="revokeConfirm">Are you sure you want to revoke this certificate?</p>
+        <dl>
+          <dt trspan="serial">Serial</dt>
+          <dd id="revokeSerial"></dd>
+          <dt trspan="user">User</dt>
+          <dd id="revokeUser"></dd>
+          <dt trspan="keyId">Key ID</dt>
+          <dd id="revokeKeyId" class="text-break"></dd>
+        </dl>
+        <div class="mb-3">
+          <label for="revokeReason" class="form-label" trspan="revokeReason">Reason (optional)</label>
+          <textarea class="form-control" id="revokeReason" rows="2" trplaceholder="revokeReason"></textarea>
+        </div>
+        <input type="hidden" id="revokeSessionId">
+        <input type="hidden" id="revokeSerialInput">
+      </div>
+      <div class="modal-footer">
+        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" trspan="cancel">Cancel</button>
+        <button type="button" class="btn btn-danger" id="confirmRevoke">
+          <span class="fa fa-ban"></span>
+          <span trspan="revoke">Revoke</span>
+        </button>
+      </div>
+    </div>
+  </div>
+</div>
+
+<!-- Alert Toast -->
+<div class="toast-container position-fixed bottom-0 end-0 p-3">
+  <div id="alertToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
+    <div class="toast-header">
+      <span id="toastIcon" class="fa fa-info-circle me-2"></span>
+      <strong class="me-auto" id="toastTitle">Notification</strong>
+      <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
+    </div>
+    <div class="toast-body" id="toastMessage"></div>
+  </div>
+</div>
+
+<script type="text/javascript" src="<TMPL_VAR NAME="STATIC_PREFIX">common/js/sshcaadmin.js"></script>
+
+<TMPL_INCLUDE NAME="footer.tpl">
new file mode 100644
--- /dev/null
